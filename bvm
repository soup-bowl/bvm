#!/bin/bash

error() { #red text and exit 1
  echo -e "\e[91m$1\e[0m" 1>&2
  exit 1
}

warning() { #yellow text
  echo -e "\e[93m\e[5mâ—¢â—£\e[25m WARNING: $1\e[0m" 1>&2
}

status() { #cyan text to indicate what is happening
  
  #detect if a flag was passed, and if so, pass it on to the echo command
  if [[ "$1" == '-'* ]] && [ ! -z "$2" ];then
    echo -e $1 "\e[96m$2\e[0m" 1>&2
  else
    echo -e "\e[96m$1\e[0m" 1>&2
  fi
}

status_green() { #announce the success of a major action
  echo -e "\e[92m$1\e[0m" 1>&2
}

debug() { #an echo command that only runs when debug mode is on
  if [ "$bvm_debug" == true ];then
    echo "$@" 1>&2
  fi
}

generate_logo() { #display cool BVM logo in terminal
  #complex logo requires Unicode 13 support (libicu66+)
  #this is available in Ubuntu 20.04+ and Debian 11+
  #use simpler logo when not supported to fix issue https://github.com/Botspot/pi-apps/issues/1441
  if [ -f /usr/lib/aarch64-linux-gnu/libicudata.so ]; then
    local version="$(readlink -f /usr/lib/aarch64-linux-gnu/libicudata.so | sed -n 's/.*libicudata.so.//p')"
  elif [ -f /usr/lib/arm-linux-gnueabihf/libicudata.so ]; then
    local version="$(readlink -f /usr/lib/arm-linux-gnueabihf/libicudata.so | sed -n 's/.*libicudata.so.//p')"
  elif find /usr/lib/aarch64-linux-gnu/libicudata.so.* &>/dev/null; then
    local version="$(find /usr/lib/aarch64-linux-gnu/libicudata.so.* | head -1 | sed -n 's+^/usr/lib/aarch64-linux-gnu/libicudata.so.++p')"
  elif find /usr/lib/arm-linux-gnueabihf/libicudata.so.* &>/dev/null; then
    local version="$(find /usr/lib/arm-linux-gnueabihf/libicudata.so.* | head -1 | sed -n 's+^/usr/lib/arm-linux-gnueabihf/libicudata.so.++p')"
  else
    local version="65"
  fi
  
  if (( $(echo "$version >= 66" | bc -l) )); then
  local rpigreen='\e[38;2;106;191;75m'
  local rpired='\e[38;2;195;28;74m'
  local black='\e[30m'
  local white='\e[97m'
  echo -e "\e[96m â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ—£ ðŸ­–â–ˆðŸ­€  ðŸ­‹â–ˆðŸ­¡ â–ˆâ–ˆâ—£   â—¢â–ˆâ–ˆ ${black}  ${rpigreen}   ${black}   ${rpigreen}   ${black}           \e[38;2;241;81;27m      \e[38;2;128;204;40m      ${black}                   
\e[96m â–ˆâ–Š  ðŸ­¨â–ˆðŸ­¬ðŸ­¦â–ˆðŸ­  ðŸ­…â–ˆðŸ­› â–ˆâ–ˆâ–ˆâ—£ â—¢â–ˆâ–ˆâ–ˆ ${black}   ${rpigreen}   ${black} ${rpigreen}   ${black}            \e[38;2;241;81;27m      \e[38;2;128;204;40m      ${black}           \e[38;2;255;0;0m   ${black} \e[38;2;255;0;0m   ${black} 
\e[96m â–ˆâ–ˆâ–ˆâ–ˆâ–ˆðŸ­ª  ðŸ­–â–ˆðŸ­€ðŸ­‹â–ˆðŸ­¡  â–ˆâ–‰â—¥â–ˆðŸ­©â–ˆâ—¤ðŸ®‹â–ˆ ${black}  ${rpired}  ${black} ${rpired}   ${black} ${rpired}  ${black}     ${white}  ${black}    \e[38;2;241;81;27m      \e[38;2;128;204;40m      ${black}  ${white}      ${black}  \e[38;2;255;0;0m         ${black}
\e[96m â–ˆâ–Š  ðŸ­¨â–ˆðŸ­¬ ðŸ­¦â–ˆðŸ­ðŸ­…â–ˆðŸ­›  â–ˆâ–‰ â—¥â–ˆâ—¤ ðŸ®‹â–ˆ ${black} ${rpired} ${black} ${rpired}   ${black} ${rpired}   ${black} ${rpired} ${black}  ${white}      ${black}  \e[38;2;0;173;239m      \e[38;2;251;188;9m      ${black}           \e[38;2;255;0;0m       ${black} 
\e[96m â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ—¤   ðŸ­–â–ˆâ–ˆðŸ­¡   â–ˆâ–‰     ðŸ®‹â–ˆ ${black}  ${rpired}  ${black} ${rpired}   ${black} ${rpired}  ${black}     ${white}  ${black}    \e[38;2;0;173;239m      \e[38;2;251;188;9m      ${black}  ${white}      ${black}    \e[38;2;255;0;0m     ${black}  
${white}BOTSPOT  VIRTUAL  MACHINE  ${black}    ${rpired}     ${black}             \e[38;2;0;173;239m      \e[38;2;251;188;9m      ${black}             \e[38;2;255;0;0m   ${black}   \e[39m"
  else
    echo "BVM - botspot virtual machine (you get the boring logo - unicode 13 not found)"
  fi
  local funny_messages='"Making it easy to run a Windows 11 VM on that potato you found in the woods."
"Rest easy knowing you are better than every Windows on Raspberry user."
"Who knew a sour berry with too many seeds was this capable?"
"Introducing: a really good way to use up storage space!"
"How many of these captions do I have to write!?" -Botspot
"Is pure Linux better? Yes. But this helps more people stick around."
"Pleased to announce an even more efficient way to run inefficient software."
"PROTIP: Try selecting the lines of text above for an easter egg! :)"
"Mixing Linux and Windows... what could possibly go wrong?"
"Turns out Raspberry and Windows do mix... forming a very crunchy smoothie."
"Now your Pi can experience the joy of Windows updates!"
"Your Pi is about to feel so sophisticated. Or nauseated. Maybe both. Not sure."
"Because there is no true difference between â€˜unsupportedâ€™ and â€˜fun challenge.â€™"
"Itâ€™s Linux... Itâ€™s Windows... Itâ€™s BVM!!"
"Like my logo? Build your own logo with: https://github.com/Botspot/unicode-art"
"With BVM you get the best of both worlds... or at least bragging rights."
"Because nobody stopped to ask if this was a good idea. But clearly it is :)"
"This was a good reason to stay up all night writing bash scripts" -Botspot
"Letâ€™s find out if your hardware has quality memory and cooling. >:)"
"They said raspberries support windows. Wrong. Now the wall is stained pink."
"Run Windows 11 on a Pi and impress... well, mostly yourself."
"This is definitely what the Linux developers intended."
"Finally, a Windows 11 VM without any dark magic or human sacrifice required."
"Linux + Windows = A match made in... well, somewhere interesting."
"They said Windows on ARM was a bad idea. And I took that personally."
"Perfect for proving that â€˜just because you canâ€™ is a good enough reason!"
"Achievement unlocked: Running Windows where it absolutely should not be."
"Because sometimes, you just really need to run Notepad on a potato."
"Minimum requirements? How about minimum suggestions. Thatâ€™s better."
"The only thing more surprising than this working... is how well it works."
"Think of this as a very elaborate benchmark... for both you and your hardware."'
  echo -e "$funny_messages" | shuf | sed -n $((RANDOM%10+1))p | tee /dev/stderr | (grep -q DONATE && sleep 10)
}

get_space_free() { #Input: folder to check. Output: show many bytes can fit before the disk is full
  #this function is from wor-flasher
  df -B 1 "$1" --output=avail | tail -1 | tr -d ' '
}

list_download_languages() { #langcode:language
  echo -e "ar-sa:Arabic\npt-br:Brazilian Portuguese\nbg-bg:Bulgarian\nzh-cn:Chinese (Simplified)\nzh-tw:Chinese (Traditional)\nhr-hr:Croatian\ncs-cz:Czech
da-dk:Danish\nnl-nl:Dutch\nen-us:English (United States)\nen-gb:English International\net-ee:Estonian\nfi-fi:Finnish\nfr-fr:French\nfr-ca:French Canadian
de-de:German\nel-gr:Greek\nhe-il:Hebrew\nhu-hu:Hungarian\nit-it:Italian\nja-jp:Japanese\nko-kr:Korean\nlv-lv:Latvian\nlt-lt:Lithuanian\nnb-no:Norwegian
pl-pl:Polish\npt-pt:Portuguese\nro-ro:Romanian\nru-ru:Russian\nsr-latn-rs:Serbian Latin\nsk-sk:Slovak\nsl-si:Slovenian\nes-es:Spanish\nes-mx:Spanish (Mexico)
sv-se:Swedish\nth-th:Thai\ntr-tr:Turkish\nuk-ua:Ukrainian"

}

process_exists() { #return 0 if the $1 PID is running, otherwise 1
  #taken from pi-apps api
  [ -z "$1" ] && return 1
  
  if [ -f "/proc/$1/status" ];then
    return 0
  else
    return 1
  fi
}

umount_retry() { #wrapper for umount command - try several times if it is still mounted
  #necessary because first umount attempt usually says "target is busy"
  local tries=0
  sync
  while mountpoint -q "$1"; do
    sudo umount "$1" &>/dev/null || sleep 1
    if [ "$tries" == 10 ];then
      warning "Could not unmount $1, unmounting it lazily."
      sudo umount -l "$1"
    fi
    tries=$((tries+1))
  done
}

connect_qcow2_to_nbd() { #find unused /dev/nbd* device to use, register it with the specified qcow2 image, echo it
  sudo modprobe nbd || error "find_available_nbd: 'sudo modprobe nbd' failed"
  sync #wait for any writes to finish
  
  #find a /dev/nbd* device not in use
  local i=0
  while [ ! -z "$(lsblk /dev/nbd$i -no MOUNTPOINTS)" ];do
    [ ! -b /dev/nbd$i ] && error "connect_qcow2_to_nbd: Failed to find available nbd device! All seem to be taken. Please run lsblk to see why."
    i=$((i+1))
  done
  local nbd_device="/dev/nbd$i"
  
  #make block devices for disk image, retry up to 5 times
  i=0
  while [ $i != 5 ] && ! sudo qemu-nbd --connect="$nbd_device" "$1";do
    sudo qemu-nbd --disconnect "$nbd_device" 1>&2
    (unmount_qcow2) #unmounts it if it already is
    sleep 2
    i=$((i+1))
  done
  if [ $i == 5 ];then
    #make device failed, unmount and cleanup
    sudo qemu-nbd --disconnect "$nbd_device" 1>&2
    error "connect_qcow2_to_nbd: failed to connect $1 to nbd device for mounting"
  fi
  
  #the partition we want is partition 4, give it 8 seconds to appear
  i=0
  while [ ! -b ${nbd_device}p4 ] && [ $i != 5 ];do
    sleep 2
    i=$((i+1))
  done
  if [ $i == 5 ];then
    lsblk ${nbd_device}
    sudo qemu-nbd --disconnect "$nbd_device"
    error "connect_qcow2_to_nbd: Partition 4 not found"
  fi
  #past this point, partition 4 exists
  
  echo "$nbd_device"
}

mount_qcow2() { #mount the $1 qcow2 disk image to /media/$USER/bvm-mount$rdp_port folder (rdp_port is just a convenient way to prevent conflict
  
  #find /dev/nbd* device not in use
  local nbd_device="$(connect_qcow2_to_nbd "$1")" || exit 1
  
  #try to fix the filesystem so it can be mounted R/W even after unsafe shutdown
  if sudo ntfsfix --clear-dirty ${nbd_device}p4 ;then
    local mount_args=(-o rw,force)
  else
    local mount_args=()
  fi
  
  sudo mkdir -p /media/$USER/bvm-mount$rdp_port
  umount_retry /media/$USER/bvm-mount$rdp_port
  if ! sudo mount -t ntfs-3g "$mount_args[@]}" ${nbd_device}p4 /media/$USER/bvm-mount$rdp_port ;then
    #mount failed, unmount and cleanup
    unmount_qcow2
    error "mount_qcow2: mount command failed"
  fi
}

unmount_qcow2() { #unmount what was mounted by the mount_qcow2 function
  #find which /dev/nbd* is used by this mountpoint, before unmounting it
  local nbd_device="/dev/$(lsblk -no MOUNTPOINTS,PKNAME | grep "^/media/$USER/bvm-mount$rdp_port " | awk '{print $2}' | head -n1)"
  [ "$nbd_device" == /dev/ ] && return 1
  
  umount_retry /media/$USER/bvm-mount$rdp_port
  
  #try to remove the nbd device only if we found it earlier
  if [ ! -z "$nbd_device" ];then
    local errors
    errors="$(sudo qemu-nbd --disconnect "$nbd_device" 2>&1)" || error "unmount_qcow2: '$errors'"
  fi
  sudo rmdir /media/$USER/bvm-mount$rdp_port
}

remove_microsoft_defender() { #given mountpoint on $1, remove microsoft defender files from image
  local mountpoint="$1"
  if [ "$debloat" == true ];then
    defenderfound=0
    [ -d "$mountpoint/ProgramData/Microsoft/Windows Defender" ] && defenderfound=1
    if ! sudo rm -rf "$mountpoint/ProgramData/Microsoft/Windows Defender" "$mountpoint/ProgramData/Microsoft/Windows Defender Advanced Threat Protection"\
      "$mountpoint/ProgramData/Microsoft/Windows Security Health" "$mountpoint/Program Files/Windows Defender" \
      "$mountpoint/Program Files/Windows Defender Advanced Threat Protection" "$mountpoint/Windows/System32/smartscreen.dll" \
      "$mountpoint/Windows/System32/smartscreen.exe" "$mountpoint/Windows/System32/smartscreenps.dll" \
      "$mountpoint/Windows/SysWOW64/smartscreen.dll" "$mountpoint/Windows/SysWOW64/smartscreenps.dll" ;then
      (unmount_qcow2)
      error "Failed to remove Microsoft Defender from disk.qcow2. Most likely the install was interrupted or the VM encountered an unsafe shutdown."
    fi
    if [ "$defenderfound" == 1 ];then
      status_green "Successfully removed Microsoft Defender from disk.qcow2"
    fi
  fi
}

remove_UCPD_from_mountpoint() { #force the specified windows installation to remove UCPD.sys file (to prevent bluescreen) - by botspot
  #Fixes the BSOD reported in https://github.com/Botspot/bvm/issues/72
  #To diagnose: boot, get it to crash, shutdown.
  #find most recent crash dump in C:/Windows/Minidump
  #copy it out and analyze on another computer:
  
  #Download WinDbg Preview from the Microsoft Store
  #Open WinDbg, go to File > Open Crash Dump, select the .dmp file.
  #Run: !analyze -v
  #Look for: MODULE_NAME or IMAGE_NAME
  
  #In this case:
  #MODULE_NAME: UCPD
  #IMAGE_NAME:  UCPD.sys
  
  #workaround until fixed:
  #boot-ramfb, F8 to get boot modes, 5 to boot in safe mode with networking
  
  #location of UCPD.sys: Windows/System32/drivers/UCPD.sys
  
  local mountpoint="$1"
  if [ -e "$mountpoint/Windows/System32/drivers/UCPD.sys" ];then
    if sudo rm -f "$mountpoint/Windows/System32/drivers/UCPD.sys" ;then
      status_green "Successfully removed UCPD.sys from disk.qcow2"
    fi
  fi
}

download_windows_11arm64_22631() { #downloads older W11 version for ARMv8.0 CPUs such as the Raspberry Pi 4 or 3
  #from https://github.com/mattieb/windows-esd-to-iso/blob/main/windows-esd-to-iso
  #and from wor-flasher
  
  #convert from pretty language name to short-code used by esd releases - example: en-us
  local WIN_LANG="$(list_download_languages | grep ":${download_language}$" | awk -F: '{print $1}')"
  [ -z "$WIN_LANG" ] && error "download_windows_11arm64_22631: language must be specified in download_language variable. Get list of available languages by running $DIRECTORY/bvm list-languages"
  [ -z "$vmdir" ] && error "download_windows_11arm64_22631: download folder for installer.iso must be specified in vmdir variable"
  
  status "Downloading Windows 11 ARM64 (${download_language})"
  
  echo "  - Getting ESD download URL..."
  catalog="$(wget -nv -O- "https://worproject.com/dldserv/esd/getcatalog.php?build=22631.2861&arch=ARM64&edition=Professional")"
  catalog="$(echo "$catalog" | sed 's/></>\n</g' | sed -n '/<Languages>/q;p' | sed -n '/^<LanguageCode>'"${WIN_LANG}"'/,${p;/^<\/File>/q}')"
  
  [ -z "$catalog" ] && error "Could not get list of Windows ESD releases. If you ran this step several times recently, the site likely temporarily banned your IP address. Give it time, and check if this site is accessible from your network: https://worproject.com/dldserv/esd/getcatalog.php"
  
  rm -rf "$vmdir/esdextract" || error "Failed to remove esdextract folder"
  mkdir "$vmdir/esdextract" || error "Directory creation failed"
  
  #Get download link, size, and SHA1 hash for ESD
  local URL="$(echo "$catalog" | grep '<FilePath>' -m 1 | sed 's/<FilePath>//g' | sed 's/<\/FilePath>//g')"
  local SIZE="$(echo "$catalog" | grep '<Size>' -m 1 | sed 's/<Size>//g' | sed 's/<\/Size>//g')"
  local SHA1="$(echo "$catalog" | grep '<Sha1>' -m 1 | sed 's/<Sha1>//g' | sed 's/<\/Sha1>//g')"
  local SOURCE_FILE="$vmdir/image.esd"
  
  if [ -f "$SOURCE_FILE" ] && [ "$SHA1" == "$(echo "  - Checking validity of already downloaded image.esd" 1>&2 ; sha1sum "$SOURCE_FILE" | awk '{print $1}')" ];then
    echo "  - Not downloading $SOURCE_FILE - file exists"
  else
    echo "  - Downloading Windows ESD image"
    wget -nv --show-progress "$URL" -O "$SOURCE_FILE" || error "Failed to download ESD image"
    echo "  - Verifying download... "
    local LOCAL_SHA1="$(sha1sum "$SOURCE_FILE" | awk '{print $1}')"
    if [ "$SHA1" != "$LOCAL_SHA1" ];then
      rm -f "$SOURCE_FILE"
      error "\nSuccessfully downloaded ESD image $SOURCE_FILE, but it appears to be corrupted. Please run this script again.\n(Expected SHA1 hash is $SHA1, but downloaded file has SHA1 hash $LOCAL_SHA1"
    fi
    echo "Done"
  fi
  
  echo "  - Scanning ESD image for partitions... "
  #should always be 6, but doubles as a validity check
  local professional_partition_num="$(wiminfo "$SOURCE_FILE" | grep -xB1 'Name: *Windows 11 Pro' | head -n1 | awk '{print $2}')"
  [ -z "$professional_partition_num" ] && error "\nCould not find Windows Professional in image.esd"
  
  status "Extracting Windows Setup Media to esdextract"
  wimapply "$SOURCE_FILE" 1 "$vmdir/esdextract" || error "Operation failed"
  
  status "Extracting Microsoft Windows PE to boot.wim"
  wimexport "$SOURCE_FILE" 2 "$vmdir/esdextract/sources/boot.wim" --compress=LZX --chunk-size=32K || error "Operation failed"
  
  status "Extracting Microsoft Windows Setup to boot.wim"
  wimexport "$SOURCE_FILE" 3 "$vmdir/esdextract/sources/boot.wim" --compress=LZX --chunk-size=32K --boot || error "Operation failed"
  
  status "Extracting Windows 11 Pro to install.wim" #compression is usually LZMS with 128k chunk size, but this was taking over an hour.
  wimexport "$SOURCE_FILE" $professional_partition_num "$vmdir/esdextract/sources/install.wim" --compress=none || error "Operation failed"
  
  #Make boot noninteractive - do what patch_iso_noprompt does but ahead of time as we are creating the ISO
  cp -f "$vmdir/esdextract/efi/microsoft/boot/efisys_noprompt.bin" "$vmdir/esdextract/efi/microsoft/boot/efisys.bin" || error "Failed to copy efisys_noprompt.bin"
  
  rm -f "$vmdir/installer.iso"
  status "Making installer.iso disk image..."
  (cd "$vmdir/esdextract"; genisoimage -o "$vmdir/installer.iso" -iso-level 3 -udf -b efi/microsoft/boot/efisys.bin -no-emul-boot -V "ESD_ISO" -allow-limited-size . 2>&1 | tee >(grep -v " done," 1>&2) | tr '\n' '\r' ; exit "${PIPESTATUS[0]}") || error "Operation failed"
  
  rm -rf "$vmdir/esdextract" "$vmdir/image.esd"
}

download_windows_11arm64() { #download latest stable windows 11 ISO language $download_language to $vmdir
  # This function is adapted from the Mido project:
  # https://github.com/ElliotKillick/Mido
  # Download newer consumer Windows versions from behind gated Microsoft API
  # Further adapted by Botspot for use in BVM
  
  local session_id=""
  local iso_download_page_html=""
  local product_edition_id=""
  local language_skuid_table_json=""
  local sku_id=""
  local iso_download_link_json=""
  local iso_download_link=""
  local url="https://www.microsoft.com/en-us/software-download/windows11arm64"
  local failed_instructions="    Using a web browser, please manually download the Windows 11 ARM64 ISO from: ${url}
    Save the downloaded ISO to: ${vmdir}/installer.iso
    Make sure the file is named installer.iso
    Then run this action again."
  
  [ -z "$download_language" ] && error "download_windows_11arm64: language must be specified in download_language variable. Get list of available languages by running $DIRECTORY/bvm list-languages"
  list_download_languages | sed 's/.*://g' | grep -qFx "$download_language" || error "download_windows_11arm64: unrecognized language '$download_language'. Get list of available languages by running $DIRECTORY/bvm list-languages"
  [ -z "$vmdir" ] && error "download_windows_11arm64: download folder for installer.iso must be specified in vmdir variable"
  
  status "Downloading Windows 11 ARM64 (${download_language})"
  
  local user_agent="Mozilla/5.0 (X11; Linux x86_64; rv:100.0) Gecko/20100101 Firefox/100.0"
  session_id="$(uuidgen)"
  
  # Get product edition ID for latest release of given Windows version
  # Product edition ID: This specifies both the Windows release (e.g. 22H2) and edition ("multi-edition" is default, either Home/Pro/Edu/etc., we select "Pro" in the answer files) in one number
  # This is the *only* request we make that Fido doesn't. Fido manually maintains a list of all the Windows release/edition product edition IDs in its script (see: $WindowsVersions array). This is helpful for downloading older releases (e.g. Windows 10 1909, 21H1, etc.) but we always want to get the newest release which is why we get this value dynamically
  # Also, keeping a "$WindowsVersions" array like Fido does would be way too much of a maintenance burden
  # Remove "Accept" header that curl sends by default
  echo "  - Parsing download page: ${url}"
  iso_download_page_html="$(curl --disable --silent --user-agent "$user_agent" --header "Accept:" --max-filesize 1M --fail --proto =https --tlsv1.2 --http1.1 -- "$url")" || \
    error "    Failed to scrape the webpage on step 1.\n$failed_instructions"
  
  echo -n "  - Getting Product edition ID: "
  # tr: Filter for only numerics to prevent HTTP parameter injection
  # head -c was recently added to POSIX: https://austingroupbugs.net/view.php?id=407
  product_edition_id="$(echo "$iso_download_page_html" | grep -Eo '<option value="[0-9]+">Windows' | cut -d '"' -f 2 | head -n 1 | tr -cd '0-9' | head -c 16)"
  echo "$product_edition_id"
  
  echo "  - Permit Session ID: $session_id"
  # Permit Session ID
  # "org_id" is always the same value
  curl --disable --silent --output /dev/null --user-agent "$user_agent" --header "Accept:" --max-filesize 100K --fail --proto =https --tlsv1.2 --http1.1 -- "https://vlscppe.microsoft.com/tags?org_id=y6jn8c31&session_id=$session_id" || \
    error "    Failed to scrape the webpage on step 2.\n$failed_instructions"
  
  local profile="606624d44113"
  
  echo -n "  - Getting language SKU ID: "
  # Get language -> skuID association table
  language_skuid_table_json="$(curl --disable -s --fail --max-filesize 100K --proto =https --tlsv1.2 --http1.1 "https://www.microsoft.com/software-download-connector/api/getskuinformationbyproductedition?profile=${profile}&ProductEditionId=${product_edition_id}&SKU=undefined&friendlyFileName=undefined&Locale=en-US&sessionID=${session_id}")" || \
    error "    Failed to scrape the webpage on step 3.\n$failed_instructions"
  
  debug "language_skuid_table_json='$language_skuid_table_json'"
  sku_id="$(echo "${language_skuid_table_json}" | jq -r '.Skus[] | select(.LocalizedLanguage=="'"${download_language}"'" or .Language=="'"${download_language}"'").Id')"
  echo "$sku_id"
  [ -z "$sku_id" ] && error "    Failed to get the sku_id\n$failed_instructions"
  
  echo "  - Getting ISO download link..."
  # Get ISO download link
  # If any request is going to be blocked by Microsoft it's always this last one (the previous requests always seem to succeed)
  # --referer: Required by Microsoft servers to allow request
  iso_download_link_json="$(curl --disable -s --fail --referer "$url" "https://www.microsoft.com/software-download-connector/api/GetProductDownloadLinksBySku?profile=${profile}&productEditionId=undefined&SKU=${sku_id}&friendlyFileName=undefined&Locale=en-US&sessionID=${session_id}")"
  
  if ! [ "$iso_download_link_json" ]; then
    # This should only happen if there's been some change to how this API works
    error "    Microsoft servers gave an empty response to the request for an automated download.\n$failed_instructions"
  fi
  
  if echo "$iso_download_link_json" | grep -q "Sentinel marked this request as rejected."; then
    error "    Microsoft blocked the automated download request based on your IP address. Follow the instructions below, or wait an hour and try again to see if your IP has been unblocked.\n$failed_instructions"
  fi
  
  # Filter for ARM 64-bit ISO download URL
  iso_download_link="$(echo "${iso_download_link_json}" | jq -r '.ProductDownloadOptions[].Uri' | grep Arm64)"
  
  if ! [ "$iso_download_link" ]; then
    # This should only happen if there's been some change to the download endpoint web address
    debug "iso_download_link_json='${iso_download_link_json}'"
    error  "  - Microsoft servers gave no download link to the request for an automated download. Please manually download this ISO in a web browser: $url"
  fi
  
  echo "  - URL: ${iso_download_link%%\?*}"
  debug "  - iso_download_link='${iso_download_link}'"
  
  # Download ISO
  wget -nv --show-progress "${iso_download_link}" -O "${vmdir}/installer.iso" || error "Failed to download Windows 11 installer.iso from Microsoft\n$failed_instructions"
  
  #verify
  echo -n "  - Verifying download... "
  sha256="$(sha256sum "${vmdir}/installer.iso" | awk '{print $1}')"
  echo Done
  if echo "$iso_download_page_html" | grep -qiF "$sha256" ;then #webpage has a list of sha256 sums per language, and the langs are named differently than here. So just check if it matches any of them.
    echo "  - Verification successful."
  else
    rm -f "${vmdir}/installer.iso"
    error "installer.iso seems corrupted after download. Its sha256sum was:\n$sha256\nwhich does not match any on this list:$(echo "$iso_download_page_html" | grep '<td>' | sed 's/<td>//g ; s+</td>++g ; s/<tr>//g ; s+</tr>++g')"
  fi
}

patch_iso_noprompt() { #force the specified windows iso not require keypress to boot into installer - by botspot

  #replace inside the ISO efisys.bin with contents of efisys_noprompt.bin
  #efisys.bin contains cdboot.pdb string
  #efisys_noprompt.bin contains cdboot_noprompt.pdb string
  #both files are the exact same length, so as long as they are in one piece in the ISO, we can replace one with the other using dd.
  #find and extract efisys_noprompt.bin, then find instances of efisys.bin and replace with efisys_noprompt.bin
  
  #where in the efisys.bin file the 'cdboot.pdb' string is,
  #and where in the efisys_noprompt.bin file the 'cdboot_noprompt.pdb' string is (how far to backtrack)
  #found with grep -abo 'cdboot\.pdb' '/mnt/winiso/efi/microsoft/boot/efisys.bin' | awk -F: '{print $1}'
  local match_offset=934748
  
  #the total length of efisys.bin or efisys_noprompt.bin files (how much data to copy)
  #found with wc -c
  local file_length=1720320
  
  local ISO="$1"
  local match
  
  #first find and extract efisys_noprompt.bin in ISO, to avoid distributing it ourselves
  status "Modifying Windows ISO to boot to installer without keypress:"
  echo "  - Searching for efisys_noprompt.bin to extract..."
  while read match ;do
    local start_offset=$((match-match_offset))
    
    #check if this is the expected start of file, - there is one false positive in testing
    if [ "$(dd if="$ISO" skip=$start_offset bs=1 count=16 status=none | base64)" != '6zyQTVNETUYzLjIAAgIBAA==' ];then
      echo "  - negative match at byte $start_offset"
      continue #back to start of loop, avoid overwriting random bits of the ISO if we did not find the expected start of the file
    fi
    echo "  - positive match at byte $start_offset"
    
    #copy the file to /tmp and exit the loop
    echo "  - Extracting it..."
    dd if="$ISO" bs=1 skip=$start_offset count="$file_length" of=/tmp/efisys_noprompt.bin status=none
    break
    
  done < <(grep -abo 'cdboot_noprompt\.pdb' "$ISO" | awk -F: '{print $1}')
  
  #make sure efisys_noprompt.bin was extracted successfully
  if [ ! -f /tmp/efisys_noprompt.bin ];then
    error "Failed to extract efisys_noprompt.bin from ISO!"
  elif [ "$(sha1sum /tmp/efisys_noprompt.bin | awk '{print $1}')" != '906e019eb371949290df917e73e387f8a18696d7' ];then
    error "The extracted efisys_noprompt.bin had an unexpected hash sum"
  else
    echo "  - Checksums match! Now searching ISO for sections to replace..."
  fi
  
  #now find byte offsets for efisys.bin in the ISO, and overwrite those sections of the ISO with efisys_noprompt.bin
  #search for cdboot.pdb in the iso, noting the offsets, and subtracting the offset of cdboot.pdb string to get start offset of file
  while read match ;do
    start_offset=$((match-match_offset))
    
    #check if this is the expected start of file - there is one false positive in testing
    if [ "$(dd if="$ISO" skip=$start_offset bs=1 count=16 status=none | base64)" != '6zyQTVNETUYzLjIAAgIBAA==' ];then
      echo "  - negative match at byte $start_offset, continuing to search..."
      continue #back to start of loop, avoid overwriting random bits of the ISO if we did not find the expected start of the file
    fi
    
    echo "  - positive match at byte $start_offset, replacing the next $file_length bytes..."
    dd if=/tmp/efisys_noprompt.bin of="$ISO" bs=1 seek=$start_offset conv=notrunc status=none
    
  done < <(grep -abo 'cdboot\.pdb' "$ISO" | awk -F: '{print $1}')
  
  rm -f /tmp/efisys_noprompt.bin
  echo "Done"
}

get_codename() { #get debian/ubuntu codename
  #taken from pi-apps
  if ! command -v lsb_release >/dev/null; then
    sudo apt update &>/dev/null && \
    sudo apt-get install -y lsb-release &>/dev/null
  fi
  
  # first check if lsb_release has an upstream option -u
  # if not, check if there is an upstream-release file
  # if not, check if there is a lsb-release.diverted file
  # if not, assume that this is not a ubuntu derivative
  if lsb_release -a -u &>/dev/null; then
    # This is a Ubuntu Derivative, checking the upstream-release version info
    lsb_release -s -c -u
  elif [ -f /etc/upstream-release/lsb-release ]; then
    # ubuntu 22.04+ linux mint no longer includes the lsb_release -u option
    # add a parser for the /etc/upstream-release/lsb-release file
    source /etc/upstream-release/lsb-release
    echo "$DISTRIB_CODENAME"
    unset DISTRIB_ID DISTRIB_DESCRIPTION DISTRIB_RELEASE DISTRIB_CODENAME
  elif [ -f /etc/lsb-release.diverted ]; then
    # ubuntu 22.04+ popOS no longer includes the /etc/upstream-release/lsb-release or the lsb_release -u option
    # add a parser for the new /etc/lsb-release.diverted file
    source /etc/lsb-release.diverted
    echo "$DISTRIB_CODENAME"
    unset DISTRIB_ID DISTRIB_DESCRIPTION DISTRIB_RELEASE DISTRIB_CODENAME
  else
    lsb_release -s -c
  fi
}

package_installed() { #exit 0 if $1 package is installed, otherwise exit 1
  #from pi-apps
  local package="$1"
  [ -z "$package" ] && error "package_installed(): no package specified!"
  #find the package listed in /var/lib/dpkg/status
  #package_info "$package"
  
  #directly search /var/lib/dpkg/status
  grep -x "Package: $package" /var/lib/dpkg/status -A 2 | grep -qxF 'Status: install ok installed'
}

package_available() { #determine if the specified package-name exists in a local repository for the current dpkg architecture
  local package="$(awk -F: '{print $1}' <<<"$1")"
  local dpkg_arch="$(awk -F: '{print $2}' <<<"$2")"
  [ -z "$dpkg_arch" ] && dpkg_arch="$(dpkg --print-architecture)"
  [ -z "$package" ] && error "package_available(): no package name specified!"
  local output="$(apt-cache policy "$package":"$dpkg_arch" | grep "Candidate:")"
  if [ -z "$output" ]; then
    return 1
  elif echo "$output" | grep -q "Candidate: (none)"; then
    return 1
  else
    return 0
  fi
}

install_dependencies() { #try to install everything BVM needs
  required_commands="git jq wget mkisofs qemu-img qemu-system-aarch64 remmina nmap wget yad uuidgen wiminfo socat ntfsresize nc"
  apt_packages="git jq wget genisoimage qemu-utils qemu-system-arm qemu-system-gui qemu-efi-aarch64 remmina remmina-plugin-rdp nmap wget yad uuid-runtime seabios ipxe-qemu wimtools socat ntfs-3g netcat-traditional"
  
  #using freerdp version 2 instead of 3 because it does not freeze on login and has more reliable clipboard sync
  if [ "$XDG_SESSION_TYPE" == wayland ];then
    #freerdp2 is not available on debian Trixie; rather than switch to freerdp3 and cause regressions, as remmina is better simply don't install freerdp2 if not found.
    if package_available freerdp2-wayland ;then
      required_commands+=" wlfreerdp"
      apt_packages+=" freerdp2-wayland"
    fi
  else
    if package_available freerdp2-x11 ;then
      required_commands+=" xfreerdp"
      apt_packages+=" freerdp2-x11"
    fi
  fi
  
  #check if any commands are absent
  local IFS=' '
  local cmd
  local installneeded=0
  for cmd in $required_commands ;do
    if [ -f /usr/bin/$cmd ];then
      continue
    elif command -v "$cmd" >/dev/null ;then
      continue
    else
      installneeded=1
      break
    fi
  done
  #Not all dependencies have commands. Check for absent needed files
  if [ ! -f /usr/share/qemu-efi-aarch64/QEMU_EFI.fd ];then
    #qemu-efi-aarch64 is missing
    installneeded=1
  elif [ ! -f /usr/lib/aarch64-linux-gnu/remmina/plugins/remmina-plugin-rdp.so ];then
    #remmina-plugin-rdp is missing
    installneeded=1
  elif [ ! -f /usr/share/seabios/vgabios-ramfb.bin ];then
    #seabios is missing
    installneeded=1
  elif [ ! -f /usr/lib/ipxe/qemu/pxe-virtio.rom ];then
    #ipxe-qemu is missing
    installneeded=1
  fi
  
  #hide the changelog
  export DEBIAN_FRONTEND=noninteractive
  #install dependencies with apt, if apt is found
  if [ "$installneeded" == 1 ] && command -v apt >/dev/null;then
    status "Installing dependencies, please wait..."
    #don't change the flags here in this apt command without updating the apt-detecting code on the pi-apps install script for BVM
    IFS=' '
    will_install=''
    for package in $apt_packages ;do
      if ! package_installed "$package" ;then
        will_install+=" $package"
      fi
    done
    
    #run apt update only if necessary
    if [ ! -f /var/cache/apt/pkgcache.bin ];then
      sudo apt update
    fi
    
    sudo apt install -y $will_install || error "APT failed to install required dependencies"
    
    #upgrade qemu to version from bookworm-backports
    if [ "$(get_codename)" == bookworm ];then
      status "Upgrading QEMU to version from bookworm-backports repository..."
      echo "deb http://deb.debian.org/debian bookworm-backports main contrib non-free non-free-firmware" | sudo tee /etc/apt/sources.list.d/bookworm-backports.list >/dev/null
      sudo apt update
      sudo apt install -y -t bookworm-backports --only-upgrade qemu-system-arm qemu-system-gui || error "Failed to upgrade qemu-system-arm to the version from the Debian bookworm-backports repository."
    fi
    status_green "Package installation complete!"
  elif [ "$installneeded" == 1 ];then
    #dependencies needed, but this is not a debian distro
    error "BVM needs these dependencies: $apt_packages\nBVM could not install them for you as your distro is not based on Debian, or at least, the apt command could not be found.\nPlease install the dependencies yourself, then try again."
  fi
  
  #make menu launcher for GUI mode
  if [ ! -f ~/.local/share/applications/bvm.desktop ] || ! grep -qF "$DIRECTORY/bvm" ~/.local/share/applications/bvm.desktop ;then
    mkdir -p ~/.local/share/applications
    echo "[Desktop Entry]
Name=Botspot Virtual Machine
Comment=Simple GUI for running Windows 11 with BVM
Exec=${DIRECTORY}/bvm gui
Icon=${DIRECTORY}/resources/graphics/icon.png
Terminal=false
StartupWMClass=bvm
Type=Application
Categories=Office
StartupNotify=true" > ~/.local/share/applications/bvm.desktop
  fi
  
  #make terminal command (may only work on future shell logins)
  mkdir -p ~/.local/bin
  [ ! -e ~/.local/bin/bvm ] && status "From now on you should be able to run BVM simply with 'bvm'. The command might not be detected by this terminal, but will work on future terminals."
  ln -sf "${DIRECTORY}/bvm" ~/.local/bin/bvm
}

qemu_newer_than() { #check if QEMU is newer than specified version, return 0 if yes, return 1 if no
  #adapted from pi-apps package_is_new_enough function
  local qemu_version="$(qemu-system-aarch64 --version | head -n1 | awk '{print $4}')"
  local compare_version="$1"
  #given both the package_version and compare_version, see if the greater of the two is the available package's version
  if [ "$(echo "$qemu_version"$'\n'"$compare_version" | sort -rV | head -n1)" == "$qemu_version" ];then
    #if so, indicate success
    return 0
  else
    return 1
  fi
}

update_check() { #check for updates and reload the script if necessary
  localhash="$(cd "$DIRECTORY" ; git rev-parse HEAD)"
  latesthash="$(git ls-remote https://github.com/Botspot/bvm HEAD | awk '{print $1}')"
  if [ "$localhash" != "$latesthash" ] && [ ! -z "$latesthash" ] && [ ! -z "$localhash" ];then
    if [ "$disable_updates" == true ];then
      echo "Updates available, but you have auto-updates disabled."
      return 0
    fi
    echo "Auto-updating BVM for the latest features and improvements..."
    (cd "$DIRECTORY"
    git restore . #abandon changes to tracked files (otherwise users who modified this script are left behind)
    git -c color.ui=always pull | cat #piping through cat makes git noninteractive
    exit "${PIPESTATUS[0]}")
    
    if [ $? == 0 ];then
      echo "git pull finished. Reloading script..."
      "$DIRECTORY/bvm" "${original_flags[@]}"
      exit $?
    else
      warning "update_check: git pull failed. Continuing..."
    fi
  fi
}

copy_icons() { #install icons to a location where the panel will notice them
  mkdir -p ~/.local/share/icons/hicolor/scalable/apps
  if [ ! -f ~/.local/share/icons/hicolor/scalable/apps/bvm.png ];then
    ln -sf "$DIRECTORY/resources/graphics/icon.png" ~/.local/share/icons/hicolor/scalable/apps/qemu.png
    ln -sf "$DIRECTORY/resources/graphics/icon.png" ~/.local/share/icons/hicolor/scalable/apps/wlfreerdp.png
    ln -sf "$DIRECTORY/resources/graphics/icon.png" ~/.local/share/icons/hicolor/scalable/apps/xfreerdp.png
    ln -sf "$DIRECTORY/resources/graphics/icon.png" ~/.local/share/icons/hicolor/scalable/apps/bvm.png
  fi
  #for wf-panel-pi at least, updating icon caches seems to do no good
}

is_atomics_cpu() { #check if this CPU supports latest Windows 11, which requires the 'atomics' CPU instruction
  cat /proc/cpuinfo | grep -qw 'Features.*atomics'
}

list_cores_to_use() { #Support big.LITTLE cpus such as RK3588. List the performance cores, or all cores if all are equal. Return 1 if performance cores detected.
  local cores="$(cat /proc/cpuinfo | grep '^CPU part\|^processor\|^$' | tr '\n' '\r' | sed 's/\r\r/\n/g ; s/\r/ /g')"
  
  #check for big.LITTLE cores without a hard-coded list of which ones are big or little
  #sort the CPU part numbers; cores with a greater hexadecimal value are the big ones
  #use alphabet substitution cipher to sort easily, then convert back to hexadecimal
  local big_core="$(echo "$cores" | grep -o '0x.*' | tr '0123456789abcdef' 'abcdefghijklmnop' | sort | tail -1 | tr 'abcdefghijklmnop' '0123456789abcdef')"
  
  #only list core lines that are that part number (could be the whole set, or a subset)
  local big_cores="$(echo "$cores" | grep "$big_core$")"
  
  #list those cores (only the core numbers for taskset to use)
  echo "$big_cores" | awk '{print $3}'
  
  if [ "$cores" != "$big_cores" ];then
    #indicate that cores listed is a subset, and taskset is needed
    return 1
  else
    #all cores were returned
    return 0
  fi
}

qemu_exitcode_analyzer() { #run after failed QEMU and suggest ZRAM if it was killed
  case $? in
    137)
      error "QEMU was terminated for using too much RAM. Try enabling ZRAM.\nInstructions: https://pi-apps.io/install-app/install-more-ram-on-raspberry-pi"
      ;;
    *)
      error "QEMU did not exit successfully. Code was $?"
  esac
}

usb_passthrough_frontend() { #help the user add USB devices to be forwarded to the VM
  if [ -z "$vmdir" ];then
    echo "usb_passthrough_frontend: needs vmdir set" 1>&2
    exit 1
  fi
  
  output="$(lsusb | grep -vi ' hub$' | awk '{for(i=6; i<=NF; i++) printf "%s ", $i; print ""}' | sed 's/^/FALSE\n/ ; s/ /\n/' | yad \
    --window-icon "${DIRECTORY}/resources/graphics/icon.png" --class bvm --name bvm --title "BVM USB Passthrough Manager" \
    --width=510 --height=400 --center \
    --list --no-headers --checklist --column=:CHK --column=sysname --column=name --separator='\n' --print-column=2 \
    --text="Select USB devices to forward to the VM."$'\n'"Forwarded devices will stop working on Linux while the VM is running."$'\n'"Keyboard/mouse: bad idea unless you need all Windows keyboard shortcuts. Must use viewing mode "\""Direct"\"".")" || return 0
  
  if [ -z "$output" ];then
    #no devices specified, reset line to default and comment it out
    sed -i "s/^usb_passthrough=.*/#usb_passthrough='05dc:a720'/g" "$vmdir/bvm-config"
  else
    #First make sure config file has usb_passthrough section. If not, add it.
    grep -q usb_passthrough "$vmdir/bvm-config" || echo "
#USB forwarding: uncomment this line for the VM to have direct access to a USB device.
#usb_passthrough='05dc:a720'
#Replace 05dc:a720 with the value you see, for the device you want, from the output of lsusb
#For multiple devices, keep it in those quotes, but separate each one with a space character." >> "$vmdir/bvm-config"
    
    #edit config file to uncomment the line and replace it with user-selected list of usb devices
    sed -i "s/^#usb_passthrough=/usb_passthrough=/g ; s/^usb_passthrough=.*/usb_passthrough='$(echo "$output" | grep . | tr '\n' ' ' | sed 's/ $//g')'/g" "$vmdir/bvm-config"
  fi
}
export -f usb_passthrough_frontend #make available to clickhandler

#full path to the bvm folder storing this script
DIRECTORY="$(readlink -f "$(dirname "$(readlink -f "$0")")")"

#Track the original arguments given to the script in order to restart in an update
original_flags=("$@")

mode="$1"
vmdir="$2"
if [ -z "$mode" ];then
  (error "Must specify a mode")
  mode=help #display help message then exit
else
  #check if it is okay for $vmdir to not exist
  case "$mode" in 
    help|list-languages|gui)
      true #no vmdir needed
      ;;
    new-vm)
      #vmdir needed.
      if [ -z "$vmdir" ];then
        (error "Must specify a directory for this mode")
        mode=help #display help message then exit
      fi
      ;;
    *)
      #vmdir needed. vmdir must exist for these modes
      if [ -z "$vmdir" ];then
        (error "Must specify a directory for this mode")
        mode=help #display help message then exit
      elif [ ! -d "$vmdir" ];then
        (error "Provided VM directory '$vmdir' does not exist! Allow this script to create one with the \e[4mnew-vm\e[24m mode.")
        mode=help #display help message then exit
      fi
      ;;
  esac
fi

IFS=$'\n'
[ "$nosplash" != true ] && generate_logo

#get configuration settings from bvm-config file
if [ ! -z "$vmdir" ];then
  #make sure vmdir is full paths, not ./
  vmdir="$(readlink -f "$vmdir")"
  if [ -f "$vmdir/bvm-config" ];then
    debug "sourcing $vmdir/bvm-config"
    . "$vmdir/bvm-config"
  fi
fi
[ -z "$vm_username" ] && vm_username=Win11ARM
[ -z "$vm_password" ] && vm_password=win11arm
[ -z "$rdp_port" ] && rdp_port=3389
[ -z "$download_language" ] && download_language="English (United States)"
[ -z "$debloat" ] && debloat=true
[ -z "$disksize" ] && disksize=40
[ -z "$free_ram_goal" ] && free_ram_goal=100
[ -z "$fullscreen" ] && fullscreen=false
if [ -z "$vm_mem" ];then
  #choose RAM to allocate to VM - 1GB less than total RAM
  vm_mem="$(($(awk '/MemTotal/ {print $2}' /proc/meminfo)/1024/1024))"
  #Force 2GB on <=2GB devices
  [ "$vm_mem" -le 1 ] && vm_mem=2
  #Take off 1GB on >=5GB devices
  [ "$vm_mem" -ge 4 ] && vm_mem=$((vm_mem-1))
  #so for boot mode, RAM allocation works out like this:
  #Pi     VM
  #1GB -> 2GB (likely fails)
  #2GB -> 2GB
  #4GB -> 3GB
  #8GB -> 6GB
  #16GB -> 14GB
  
  #more than 4GB has no benefit for firstinstall
  [ "$mode" == firstboot ] && [ "$vm_mem" -gt 4 ] && vm_mem=4
fi

#fixes https://github.com/Botspot/bvm/issues/26
export PAN_MESA_DEBUG=gl3

debug "DIRECTORY: $DIRECTORY
mode: $mode
vmdir: $vmdir
vm_username: $vm_username
vm_password: $vm_password
vm_mem: $vm_mem
rdp_port: $rdp_port
download_language: $download_language
disksize: $disksize
debloat: $debloat
fullscreen: $fullscreen"

#check for updates
update_check
copy_icons

#check system for compatibility
if [ "$(id -u)" == 0 ]; then
  error "BVM cannot be run as root user. Wayland programs need to be run as a non-root user."
elif [ "$(modinfo --filename kvm)" != "(builtin)" ] && ! sudo modprobe kvm ;then
  error "User error: KVM kernel module is needed but missing. Command that failed was 'sudo modprobe kvm'"

#it seems being part of the kvm group is unnecessary
#elif ! groups | grep -q ' kvm ' ;then
#  sudo usermod -aG kvm $USER
#  error "Your user was not part of kvm group. Now they are. Please reboot."
#fi
#check RAM and choose how much to allocate the VM
elif [ "$(awk '/MemTotal/ {print $2}' /proc/meminfo)" -le $((1*1024*1024)) ];then
  error "User error: Your system needs at least 2 GB of RAM. Be aware that a VM might be able to boot on 1 GB of RAM, but it cannot install Windows with less than 2 GB."
#check OS architecture: ARM64 userland required
elif [ "$(od -An -t x1 -j 4 -N 1 "$(readlink -f /sbin/init)")" = ' 01' ];then
  error "User error: OS CPU architecture is 32-bit! BVM only works on ARM 64-bit operating systems."
#check storage location for ISO is not a FAT partition
elif [ ! -z "$vmdir" ] && df -T "$vmdir" 2>/dev/null | grep -q 'fat' ;then
  error "The $DL_DIR directory is on a FAT32/FAT16/vfat partition. This type of partition cannot contain files larger than 4GB, however the Windows image will be larger than that.\nPlease format the drive with an Ext4 partition, or use another drive."
fi

#avoid trying to run sudo not in a terminal, in case a password is necessary
if [ "$mode" != gui ];then
  install_dependencies || exit 1
fi

echo "BVM mode $mode"

case "$mode" in
  help)
    echo -e "BVM HELP:   --------------------------------------------------------------------
\e[96mAll primary modes: new-vm, download, prepare, firstboot, boot, connect, mount, expand\e[0m
You generally want to run the modes in that order.
Additional modes: help, list-languages, boot-nodisplay, boot-ramfb, boot-gtk, connect-freerdp, connect-remmina

To get a fresh VM up and running, use a sequence like this:
\e[96m$0 new-vm $HOME/win11\e[0m
 This makes a config file: $HOME/win11/bvm-config   <--- Please read it!
\e[96m$0 download $HOME/win11\e[0m
 This downloads Windows and necessary drivers.
\e[96m$0 prepare $HOME/win11\e[0m
 This bundles everything up to get ready for first boot.
\e[96m$0 firstboot $HOME/win11\e[0m
 If the Windows install is interrupted, just run this step again.
 Be aware: when Windows finishes installing, the VM will shutdown.
 All .iso files and the unattended folder could be removed once this step is done.
\e[96m$0 boot $HOME/win11\e[0m
 Main command to use the VM.
 This works, but is a little laggy and lacks crucial features.
 It is recommended to boot the VM headless and then connect to it via RDP:
\e[96m$0 boot-nodisplay $HOME/win11\e[0m
 Then in a second shell, connect to the RDP service:
\e[96m$0 connect $HOME/win11\e[0m
 The connect mode has better audio, clipboard sync, file sharing, dynamic screen resizing, and a higher frame rate.
 Mount the Windows main hard drive with:
\e[96m$0 mount $HOME/win11\e[0m
 Be aware: the VM needs to be shut down properly to mount in read/write mode.
 Expand the main Windows hard drive with:
\e[96m$0 expand $HOME/win11\e[0m" | sed "s+$HOME/+~/+g"
    ;;
    
  list-languages)
    list_download_languages | sed 's/.*://g'
    ;;
    
  gui)
    
    [ -z "$vmdir" ] && vmdir=$HOME/win11
    clickhandler() {
      
      local define_step_complete="step_complete() { #runs after our main command, keeps the terminal open and 
        if [ \$? == 0 ];then
          echo -e '\e[102m\e[30mOperation succeeded. Please close this terminal to proceed to the next step.\e[0m'
          read enter
        else
          echo -e '\e[101m\e[30mOperation failed! Please review the errors above.\e[0m'
          read enter
        fi
      }
      "
      
      run_in_terminal() {
        #echo "$1" 1>&2
        "${DIRECTORY}/resources/terminal-run" "$define_step_complete$1" "BVM operation in progress"
      }
      #uncomment to skip running steps for debugging
      #run_in_terminal() {
      #  step_complete "$(echo "$1" | awk '{print $NF}')" 1>&2
      #}
      
      #undo our hack and allow text editors to use wayland
      unset GDK_BACKEND
      export GDK_BACKEND
      echo "clickhandler: $*" 1>&2
      case "$1" in
        newvm) #1
          if [ -f "$vmdir/gui-steps-complete" ];then
            #pick location for new VM, this one already exists
            vmdir="$(yad --window-icon "${DIRECTORY}/resources/graphics/icon.png" --class bvm --name bvm --title "BVM" --center --directory --file --save --width 500 --text="$vmdir already exists."$'\n'"Proceed only if you are trying to make a second VM.")"
            if [ ! -z "$vmdir" ] && [ "$vmdir" != "$HOME" ];then
              kill $YAD_PID
              export vmdir
              setsid "${DIRECTORY}/bvm" gui 1>&2
            fi
          else
            run_in_terminal "${DIRECTORY}/bvm new-vm '$vmdir' ; step_complete"
          fi
          ;;
        editconf) #2
          #workaround PiOS opening this in Chromium for some reason
          if command -v geany >/dev/null ;then
            setsid geany "$vmdir/bvm-config" &
          else
            setsid xdg-open "$vmdir/bvm-config" &
          fi
          sleep 5
          #mark this step as complete
          if [ 2 -gt "$(cat "$vmdir/gui-steps-complete")" ];then
            echo 2 > "$vmdir/gui-steps-complete"
          fi
          ;;
        download) #3
          run_in_terminal "${DIRECTORY}/bvm download '$vmdir' ; step_complete"
          ;;
        prepare) #4
          run_in_terminal "${DIRECTORY}/bvm prepare '$vmdir' ; step_complete"
          ;;
        firstboot) #5
          run_in_terminal "${DIRECTORY}/bvm firstboot '$vmdir' ; step_complete"
          ;;
        boot) #6, view mode provided on $2
          
          #change green message to not say next step
          define_step_complete="$(echo "$define_step_complete" | sed 's+Please close this terminal to proceed to the next step\.+Thank you for using BVM! This terminal can be closed now.+g')"
          
          if [[ "$2" == *'fullscreen' ]];then
            fullscreen=true
          else
            fullscreen=false
          fi
          
          case "$2" in
            'Direct RAMFB'*)
              run_in_terminal "export fullscreen=$fullscreen ; ${DIRECTORY}/bvm boot-ramfb '$vmdir' ; step_complete"
              ;;
            Direct*)
              run_in_terminal "export fullscreen=$fullscreen ; ${DIRECTORY}/bvm boot-gtk '$vmdir' ; step_complete"
              ;;
            FreeRDP*)
              run_in_terminal "export fullscreen=$fullscreen ; ${DIRECTORY}/bvm boot-nodisplay '$vmdir' & pid=\$! ; while [ -f /proc/\$pid/status ] && [ ! -f /proc/\$(cat '$vmdir/qemu.pid' 2>/dev/null)/status ];do sleep 1 ;done; nosplash=true ${DIRECTORY}/bvm connect-freerdp '$vmdir' ; step_complete"
              ;;
            Remmina*)
              run_in_terminal "export fullscreen=$fullscreen ; ${DIRECTORY}/bvm boot-nodisplay '$vmdir' & pid=\$! ; while [ -f /proc/\$pid/status ] && [ ! -f /proc/\$(cat '$vmdir/qemu.pid' 2>/dev/null)/status ];do sleep 1 ;done; nosplash=true ${DIRECTORY}/bvm connect-remmina '$vmdir' ; step_complete"
              ;;
            *)
              error "clickhandler: unrecognized boot gui mode"
              ;;
          esac
          ;;
        mount)
          #change green message to not say next step
          define_step_complete="$(echo "$define_step_complete" | sed 's+Please close this terminal to proceed to the next step\.+Thank you for using BVM! This terminal can be closed now.+g')"
          run_in_terminal "${DIRECTORY}/bvm mount '$vmdir' ; step_complete"
          ;;
        expand)
          #change green message to not say next step
          define_step_complete="$(echo "$define_step_complete" | sed 's+Please close this terminal to proceed to the next step\.+Thank you for using BVM! This terminal can be closed now.+g')"
          run_in_terminal "${DIRECTORY}/bvm expand '$vmdir' ; step_complete"
          ;;
        usbsetup)
          usb_passthrough_frontend
          ;;
        *)
          echo "clickhandler: unknown button" 1>&2
          ;;
      esac
      
      #unlock the next button (overwrites its own button if action failed, effectively doing nothing)
      case "$(cat "$vmdir/gui-steps-complete")" in
        1)
          echo "2:$button2"
          ;;
        2)
          echo "3:$button3"
          ;;
        3)
          echo "4:$button4"
          ;;
        4)
          echo "5:$button5"
          ;;
        5)
          echo "6:$button6"
          echo "8:$mount_button"
          echo "9:$expand_button"
          echo "10:$usbsetup_button"
          ;;
      esac
      exit 0
    }
    
    export -f clickhandler
    export DIRECTORY vmdir
    
    export button2="@bash -c 'clickhandler editconf'"
    export button3="@bash -c 'clickhandler download'"
    export button4="@bash -c 'clickhandler prepare'"
    export button5="@bash -c 'clickhandler firstboot'"
    export button6="@bash -c "\""clickhandler boot %7"\"""
    echo "button6 is $button6"
    export mount_button="@bash -c 'clickhandler mount'"
    export expand_button="@bash -c 'clickhandler expand'"
    export usbsetup_button="@bash -c 'clickhandler usbsetup'"
    initial_button2="@disabled@"
    initial_button3="@disabled@"
    initial_button4="@disabled@"
    initial_button5="@disabled@"
    initial_button6="@disabled@"
    initial_mount_button="@disabled@"
    initial_expand_button="@disabled@"
    initial_usbsetup_button="@disabled@"
    if [ ! -f "$vmdir/gui-steps-complete" ];then
      steps_complete=0
    else
      steps_complete="$(cat "$vmdir/gui-steps-complete")"
      #based on the last complated step, unlock the appropriate buttons
      if [ "$steps_complete" -ge 1 ];then
        initial_button2="$button2"
      fi
      if [ "$steps_complete" -ge 2 ];then
        initial_button3="$button3"
      fi
      if [ "$steps_complete" -ge 3 ];then
        initial_button4="$button4"
      fi
      if [ "$steps_complete" -ge 4 ];then
        initial_button5="$button5"
      fi
      if [ "$steps_complete" -ge 5 ];then
        initial_button6="$button6"
        initial_mount_button="$mount_button"
        initial_expand_button="$expand_button"
        initial_usbsetup_button="$usbsetup_button"
      fi
    fi
    
    #the window freezes while running a task, and wayland times it out, so run on xwayland
    GDK_BACKEND=x11 yad --window-icon "${DIRECTORY}/resources/graphics/icon.png" --class bvm --name bvm --title "BVM" --form --center --width 400 \
      --image "${DIRECTORY}/resources/graphics/icon-80.png" --image-on-top --no-buttons \
      --text="Botspot Virtual Machine, at your service.$([ "$vmdir" != "$HOME/win11" ] && echo -e "\nvmdir: <u>$vmdir</u>")" \
      --field="<b>New Virtual Machine</b>!${DIRECTORY}/resources/graphics/1.png!Make a folder to put the VM files in - by default this is ~/win11":FBTN "@bash -c 'clickhandler newvm'" \
      --field="<b>Edit configuration file</b>!${DIRECTORY}/resources/graphics/2.png!Please take the time to read through it.":FBTN "$initial_button2" \
      --field="<b>Download components</b>!${DIRECTORY}/resources/graphics/3.png!Download everything needed to complete a windows install":FBTN "$initial_button3" \
      --field="<b>Prepare for installation</b>!${DIRECTORY}/resources/graphics/4.png!Bundle up driver files and get ready for first boot":FBTN "$initial_button4" \
      --field="<b>Install Windows 11</b>!${DIRECTORY}/resources/graphics/5.png!Boot the VM for the first time to install Windows":FBTN "$initial_button5" \
      --field="<b>Run Windows 11</b>!${DIRECTORY}/resources/graphics/6.png!Boot the VM normally":FBTN "$initial_button6" \
      --field="Viewing mode:":CB "Direct RAMFB (debugging)!Direct!Direct fullscreen!FreeRDP!FreeRDP fullscreen!^Remmina!Remmina fullscreen" \
      --field="Mount disk.qcow2!!Browse the full C: drive of the VM to add/remove files":FBTN "$initial_mount_button" \
      --field="Expand disk.qcow2!!Increase the size of the storage available to the VM":FBTN "$initial_expand_button" \
      --field="USB passthrough!!Give the VM direct access to specific USB devices":FBTN "$initial_usbsetup_button"

    ;;
  new-vm)
    #initializes a new vmdir
    
    mkdir -p "$vmdir" || error "failed to create vmdir '$vmdir'!"
    
    #copy configuration file
    cp -f "${DIRECTORY}/resources/bvm-config" "$vmdir"
    #copy remmina config
    #Remmina edits its config file and removes the password on first run, so make a copy for this VM to avoid modifying the version in the main folder.
    cp -f "${DIRECTORY}/resources/connect.remmina" "$vmdir/connect.remmina"
    
    #for GUI: track which step was completed. Avoid resetting an existing value to 1
    if [ ! -f "$vmdir/gui-steps-complete" ];then
      echo 1 > "$vmdir/gui-steps-complete"
    fi
    
    status_green "You should now be ready for the next step: $0 download $vmdir"
    ;;
  download) #get everything downloaded, and leave it in a state where user can make changes easily
    
    #download installer.iso, ask for confirmation to overwrite
    if [ -f "$vmdir/installer.iso" ];then
      read -p "$(echo -ne '\e[93m')installer.iso already exists. Delete it and download a fresh copy? [Y/n]$(echo -ne '\e[0m') " answer
      [ "$answer" != n ] && rm -f "$vmdir/installer.iso"
    fi
    
    if [ ! -f "$vmdir/installer.iso" ];then
      #ensure there is free space to download everything (user can ignore this error except on GUI, where they have to edit the config to work around it)
      if [ "$(get_space_free "$vmdir")" -le $((disksize*1024*1024*1024)) ];then
        error "Insufficient free disk space. $disksize GB is needed, but you only have $(($(get_space_free "$vmdir")/1024/1024/1024)) GB. You can try reducing the desired disk size in the config file to get around this error."
      fi
      
      #get either latest ISO if CPU supports it, or W11 22631 if CPU does not support atomics
      if is_atomics_cpu ;then
        #ARM supports 'atomics' instruction, get latest windows (Pi5, other SBCs)
        #vmdir and $download_language must be set for this function
        download_windows_11arm64 || exit 1
        
      else # (Pi4)
        warning "Downloading an older Windows version that is compatible with your device. Later versions of Windows 11 require the 'atomics' ARM instruction that your CPU lacks."
        #get Windows build 22631 for Pi4s and other A53 CPUs
        download_windows_11arm64_22631 || exit 1
      fi
    fi
    
    status "Downloading virtio drivers"
    wget -nv --show-progress "https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso" -O "${vmdir}/virtio-win.iso" || error "Downloading virtio-win.iso failed"
    
    status "Downloading Windows debloating script"
    mkdir -p "$vmdir/unattended"
    #this debloat script is run by the autounattend.xml file on first login
    if [ ! -d "$vmdir/unattended/Win11Debloat" ] && [ "$debloat" == true ];then
      (cd "$vmdir/unattended" && git clone "https://github.com/Raphire/Win11Debloat") || "git clone of Win11Debloat repository failed"
    fi
    
    #copy autounattend.xml script to unattended/ now
    #this gives the user a chance to change it before it's packaged into unattended.iso
    cp -f "$DIRECTORY/resources/autounattend.xml" "$vmdir/unattended" || error "failed to copy autounattend.xml to unattended folder"
    #copy my script that runs on first login of vm
    cp -f "$DIRECTORY/resources/firstlogin.ps1" "$vmdir/unattended"
    
    #edit to pre-choose language and keyboard layout ahead of time for the top 2 most common locales
    if ! grep -qF "Microsoft-Windows-International-Core-WinPE" "$vmdir/unattended/autounattend.xml" ;then
      if [ "$download_language" == "English (United States)" ];then
        sed -i 's+<settings pass="windowsPE">+<settings pass="windowsPE">\n    <component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="arm64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n      <SetupUILanguage>\n        <UILanguage>en-US</UILanguage>\n      </SetupUILanguage>\n      <InputLocale>0409:00000409</InputLocale>\n      <SystemLocale>en-US</SystemLocale>\n      <UILanguage>en-US</UILanguage>\n      <UserLocale>en-US</UserLocale>\n    </component>+g' "$vmdir/unattended/autounattend.xml"
      elif [ "$download_language" == "English International" ];then
        sed -i 's+<settings pass="windowsPE">+<settings pass="windowsPE">\n    <component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="arm64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n      <SetupUILanguage>\n        <UILanguage>en-GB</UILanguage>\n      </SetupUILanguage>\n      <InputLocale>0809:00000809</InputLocale>\n      <SystemLocale>en-GB</SystemLocale>\n      <UILanguage>en-GB</UILanguage>\n      <UserLocale>en-GB</UserLocale>\n    </component>+g' "$vmdir/unattended/autounattend.xml"
      fi
    fi
    #set desired username and password
    sed -i "s/win11arm/${vm_password}/g ; s/Win11ARM/${vm_username}/g" "$vmdir/unattended/autounattend.xml"
    
    #copy out the arm64 virtio drivers (avoids having 2 drives which trade drive letters randomly between boots)
    status "Extracting VirtIO drivers..."
    TMP="$(mktemp -d)"
    sudo mount -r "$vmdir/virtio-win.iso" "$TMP" || error "failed to mount virtio-win.iso for extracting files"
    IFS=$'\n'
    for dir in $(find "$TMP" -type d -name ARM64 | grep w11) ;do
      #example value of dir: /tmp/tmp.coL1nQguHD/NetKVM/w11/ARM64
      drivername="$(echo "$dir" | awk -F/ '{print $4}')" #example value: NetKVM
      echo "  - $drivername"
      mkdir -p "$vmdir/unattended/$drivername"
      if ! cp -rf --no-preserve mode "$dir"/. "$vmdir/unattended/$drivername" ;then
        umount_retry "$TMP"
        error "Failed to copy $drivername to $vmdir/unattended"
      fi
    done
    mkdir -p "$vmdir/unattended/guest-agent"
    cp -f --no-preserve mode "$TMP/guest-agent/qemu-ga-x86_64.msi" "$vmdir/unattended/guest-agent"
    cp -rf --no-preserve mode "$TMP/cert" "$vmdir/unattended"
    sync
    umount_retry "$TMP" || error "Failed to unmount virtio-win.iso, please report this issue"
    rmdir "$TMP"
    
    #no need for virtio iso anymore, now that we have extracted arm64-compatible stuff
    rm -f "${vmdir}/virtio-win.iso"
    
    #the next step will convert unattended/ folder to unattended.iso
    
    #for GUI: track which step was completed (skip 2 because step 2 is edit config)
    if [ 3 -gt "$(cat "$vmdir/gui-steps-complete")" ];then
      echo 3 > "$vmdir/gui-steps-complete"
    fi
    
    status_green "You should now be ready for the next step: $0 prepare $vmdir"
    ;;
    
  prepare) #take downloaded files and get everything ready for first boot
    
    #Patch the ISO to not require a keypress to boot
    # This was moved to the prepare step to patch the iso if user manually downloaded it (see https://github.com/Botspot/bvm/issues/167)
    if is_atomics_cpu ;then
      #if pi4 version was downloaded, the iso was made with the noprompt patch already
      #avoid patching in that case - fixes https://github.com/Botspot/bvm/discussions/168
      patch_iso_noprompt "$vmdir/installer.iso" || exit 1
    fi
    
    #make drive to pass to installer (virtio arm drivers with unattended stuff and debloating script)
    status -n "Making unattended.iso... "
    #lesson learned: -J -r -allow-lowercase -allow-multidot fixes debloat script names being truncated
    mkisofs -quiet -l -J -r -allow-lowercase -allow-multidot -o "$vmdir/unattended.iso" "$vmdir/unattended/" || error "\nFailed to create unattended.iso"
    status_green Done
    
    #handle main hard drive creation
    status "Setting up main hard drive disk.qcow2"
    if [ -f "$vmdir/disk.qcow2" ];then
      warning "Proceeding will DELETE your VM's main hard drive and start over with a clean install. ($vmdir/disk.qcow2 already exists)"
      read -p "Do you want to continue? (Y/n): " answer
      [ "$answer" == "n" ] && error "Exiting as you requested"
    fi  
    rm -f "$vmdir/disk.qcow2" || error "Failed to delete $vmdir/disk.qcow2"
    
    status -n "Allocating ${disksize}GB for main install drive... "
    errors="$(qemu-img create -f qcow2 -o cluster_size=2M,nocow=on,preallocation=metadata "$vmdir/disk.qcow2" "${disksize}G" 2>&1)" || error "\nFailed to create $vmdir/disk.qcow2\nErrors:\n$errors"
    status_green Done
    
    #for GUI: track which step was completed
    if [ 4 -gt "$(cat "$vmdir/gui-steps-complete")" ];then
      echo 4 > "$vmdir/gui-steps-complete"
    fi
    
    status_green "You should now be ready for the next step: $0 firstboot $vmdir"
    ;;
    
  firstboot) #minimal QEMU command-line to get through OS installation from installer.iso to disk.qcow2
    
    if [ -z "$DISPLAY" ] && [ -z "$WAYLAND_DISPLAY" ];then
      error "BVM needs a desktop environment to run $mode"
    fi
    
    #determine if only some CPU cores can be used
    if use_cores="$(list_cores_to_use)" ;then
      #function returned 0, so all cores are the same and taskset is not needed
      use_taskset=false
    else
      #some cores are performance cores, use them
      warning "Trying to use performance cores on your CPU only. PLEASE reach out to Botspot if this does not work."
      use_taskset=true
    fi
    num_cores="$(echo "$use_cores" | wc -l)"
    
    #Duplicate unattended.iso to try to always make one of them take the F: drive letter, no matter how D: and E: decide to arrange themselves it should work
    full_qemu_flags=(-M virt,accel=kvm -cpu host -m ${vm_mem}G -smp $num_cores \
      -name BVM \
      -pidfile "$vmdir/qemu.pid" \
      -device ramfb -display gtk,grab-on-hover=on,gl=off \
      -device qemu-xhci \
      -device usb-kbd \
      -device usb-tablet \
      -device virtio-rng-pci,rng=rng0 -object rng-random,id=rng0,filename=/dev/urandom \
      -netdev user,id=nic -device virtio-net-pci,netdev=nic \
      -bios /usr/share/qemu-efi-aarch64/QEMU_EFI.fd \
      -drive media=cdrom,index=0,file="$vmdir/installer.iso",if=none,id=installer,readonly=on -device usb-storage,drive=installer \
      -drive media=cdrom,index=1,file="$vmdir/unattended.iso",if=none,id=unattended,readonly=on -device usb-storage,drive=unattended \
      -drive media=cdrom,index=2,file="$vmdir/unattended.iso",if=none,id=unattended2,readonly=on -device usb-storage,drive=unattended2 \
      -drive file="$vmdir/disk.qcow2",if=virtio,aio=threads,cache=none)
    
    debug "full_qemu_flags: " "${full_qemu_flags[@]}"
    
    status "Windows should install 100% automatically. This will take several hours."
    #run qemu with these flags
    if [ "$use_taskset" == false ];then
      qemu-system-aarch64 "${full_qemu_flags[@]}" || qemu_exitcode_analyzer
    else
      #For rockchip (untested but based on https://gist.github.com/Vogtinator/293c4f90c5e92838f7e72610725905fd?permalink_comment_id=5378278#gistcomment-5378278)
      taskset -c "$(echo "$use_cores" | tr '\n' ',' | sed 's/,$//g')" qemu-system-aarch64 "${full_qemu_flags[@]}" || qemu_exitcode_analyzer
    fi
    status "QEMU closed."
    read -p "Press Enter to continue with post-installation setup... "
    
    #check disk.qcow2 and remove microsoft defender if debloat enabled
    mountpoint="/media/$USER/bvm-mount$rdp_port"
    if ! (mount_qcow2 "$vmdir/disk.qcow2") ;then
      (unmount_qcow2)
      error "It appears that Windows installation was not completed in disk.qcow2. Mounting the hard disk image failed."
    #elif [ ! -f "$mountpoint/Program Files/Qemu-ga/qemu-ga.exe" ];then #check for qemu guest agent to determine if it was fully installed
    elif [ ! -f "$mountpoint/Windows/Temp/firstlogin_log.txt" ];then #check for firstlogin_log.txt to determine if it was fully installed
      (unmount_qcow2)
      error "It appears that Windows installation was not completed in disk.qcow2. C:/Windows/Temp/firstlogin_log.txt does not exist."
    fi
    
    remove_microsoft_defender "$mountpoint" || exit 1
    #if debloat is disabled, all this does is mount the disk.qcow2 to make sure it seems complete
    remove_UCPD_from_mountpoint "$mountpoint"
    
    unmount_qcow2 || exit 1
    
    #for GUI: track which step was completed
    if [ 5 -gt "$(cat "$vmdir/gui-steps-complete")" ];then
      echo 5 > "$vmdir/gui-steps-complete"
    fi
    status_green "You should now be ready for the next step: $0 boot $vmdir"
    ;;
    
  boot*) #complex QEMU command-line to boot OS for everyday use
    
    [ "$mode" == boot ] && warning "The plain 'boot' mode is missing features, and you can't resize the screen. To fix this, use '$0 boot-nodisplay $vmdir' and in a second terminal '$0 connect $vmdir' to use a RDP connection. Run '$0 help' for more info. To hide this warning, replace 'boot' with 'boot-gtk'."
    
    #workaround for users who experienced microsoft defender removal failure on firstboot (https://github.com/Botspot/bvm/issues/19)
    if [ "$(cat "$vmdir/gui-steps-complete")" == 4 ];then #this will be 4 because firstboot failed after succeeding
      (mount_qcow2 "$vmdir/disk.qcow2" && remove_microsoft_defender "/media/$USER/bvm-mount$rdp_port" && remove_UCPD_from_mountpoint "$mountpoint" && echo 5 > "$vmdir/gui-steps-complete")
      unmount_qcow2
    fi
    
    #all users who created a VM before May 4th 2025 need to follow these instructions
    if [ "$(stat -c %W $vmdir/disk.qcow2)" -le 1746416400 ];then
      echo -e "\e[93mIF YOU ENCOUNTER THE "\""Password Expired"\"" ERROR, FOLLOW THESE INSTRUCTIONS: https://github.com/Botspot/bvm/issues/98\e[0m" 1>&2
    fi
    
    if [ "$mode" != boot-nodisplay ] && [ -z "$DISPLAY" ] && [ -z "$WAYLAND_DISPLAY" ];then
      error "BVM needs a desktop environment to run $mode"
    fi
    
    #choose display mode (ramfb, gtk, none)
    case "$mode" in
      boot-nodisplay)
        display_flags=(-vga none -device virtio-gpu-pci -display none)
        ;;
      boot-ramfb)
        display_flags=(-vga none -device ramfb -display gtk,gl=off,grab-on-hover=on$([ "$fullscreen" == true ] && echo ',full-screen=on'))
        ;;
      boot-gtk|boot)
        display_flags=(-vga none -device virtio-gpu-pci -display gtk,gl=off,grab-on-hover=on$([ "$fullscreen" == true ] && echo ',full-screen=on'))
        ;;
      *)
        error "Unknown suffix after 'boot': '$mode'"
        ;;
    esac
    
    #check for rdp_port being already in use
    if nc -z localhost "$rdp_port" ;then
      error "Network port $rdp_port is already in use. Either you already have a Remote Desktop server, or BVM running on this system already. Either disable that other service, or change rdp_port in the bvm-config file."
    fi
    
    #determine audio backend to use, try to de-crackle it as much as possible
    if pgrep pipewire >/dev/null && qemu_newer_than 8.1.0 ;then
      #Make QEMU use pipewire output backend, if possible
      debug "Using pipewire audio backend"
      audio_flags=(-device usb-audio,audiodev=my_audiodev -audiodev "pipewire,id=my_audiodev,out.buffer-length=1000000,out.mixing-engine=off,out.fixed-settings=off")
      #if QEMU does not support pipewire, fallback to pulseaudio if pipewire's pulseaudio bridge is running
    elif pgrep pulseaudio >/dev/null || pgrep pipewire-pulse >/dev/null ;then
      #Make QEMU use pulseaudio output backend
      debug "Using pulseaudio audio backend"
      audio_flags=(-device usb-audio,audiodev=my_audiodev -audiodev "pa,id=my_audiodev,out.buffer-length=1000000")
    else
      #Make QEMU use pulseaudio output backend (fallback)
      debug "Using alsa audio backend"
      audio_flags=(-device usb-audio,audiodev=my_audiodev -audiodev "alsa,id=my_audiodev,out.buffer-length=1000000")
    fi
    
    #handle USB forwarding preferences set by usb_passthrough variable
    usb_forwarding_flags=() #this is not to be set in the config file, but created in the for loop. Set usb_passthrough instead.
    udev_file="/etc/udev/rules.d/10-bvm-hw-access${rdp_port}.rules"
    if [ ! -z "$usb_passthrough" ];then
      sudo rm -f "$udev_file"
      trap "sudo rm -f '$udev_file'" EXIT SIGINT #remove this udev rule file on exit
      IFS=' '
      for usbdev in $usb_passthrough ;do
        vendor=$(echo "$usbdev" | awk -F: '{print $1}')
        product=$(echo "$usbdev" | awk -F: '{print $2}')

        #allow non-root qemu uaccess permission to this usb device (https://bbs.archlinux.org/viewtopic.php?id=209185)
        echo 'SUBSYSTEM=="usb", ATTRS{idVendor}=="'$vendor'", ATTRS{idProduct}=="'$product'", TAG+="uaccess", GROUP="'$USER'", MODE="0660", ENV{UDISKS_IGNORE}="1", ENV{MTP_NO_PROBE}="1", ENV{ID_MTP_DEVICE}="0"' | sudo tee -a "$udev_file" >/dev/null
        usb_forwarding_flags+=(-device usb-host,vendorid=0x$vendor,productid=0x$product,bus=passthrough_xhci.0)
      done
      #now reload udev rules
      sudo udevadm control -R
      sudo udevadm trigger
      
    elif [ -f "$udev_file" ];then #if usb redirection is now disabled, make sure to remove our udev file if present
      sudo rm -f "$udev_file"
      #now reload udev rules
      sudo udevadm control -R
      sudo udevadm trigger
    fi
    
    #determine if only some CPU cores can be used
    if use_cores="$(list_cores_to_use)" ;then
      #function returned 0, so all cores are the same and taskset is not needed
      use_taskset=false
    else
      #some cores are performance cores, use them
      warning "Trying to use performance cores on your CPU only. PLEASE reach out to Botspot if this does not work."
      use_taskset=true
    fi
    num_cores="$(echo "$use_cores" | wc -l)"
    
    #forward guest's port 3389 to localhost port of our choice (handled by config file now)
    #network_flags=(-netdev user,id=nic,hostfwd=tcp:127.0.0.1:${rdp_port}-:3389 -device virtio-net-pci,netdev=nic)
    rm -f "$vmdir/qemu.pid"
    #all QEMU flags are combined together here
    full_qemu_flags=(-M virt,accel=kvm -cpu host -m ${vm_mem}G -smp $num_cores \
      -name BVM,process=bvm \
      -pidfile "$vmdir/qemu.pid" \
      -device virtio-balloon \
      -device virtio-serial-pci \
      "${display_flags[@]}" \
      -device qemu-xhci \
      -device usb-kbd \
      -device usb-tablet \
      -monitor unix:"$vmdir/qemu.sock",server,nowait \
      "${audio_flags[@]}" \
      -rtc base=localtime,clock=host,driftfix=none \
      -device virtio-rng-pci,rng=rng0 -object rng-random,id=rng0,filename=/dev/urandom \
      "${network_flags[@]}" \
      -bios /usr/share/qemu-efi-aarch64/QEMU_EFI.fd \
      -drive file="$vmdir/disk.qcow2",if=virtio,discard=unmap,aio=threads,cache=none \
      -device qemu-xhci,id=passthrough_xhci,p2=8,p3=8 \
      "${usb_forwarding_flags[@]}")
    
    debug "full_qemu_flags: " "${full_qemu_flags[@]}"
    
    #always try to pick optimal VM RAM limit by sending repeated balloon requests
    total_ram=$(grep MemTotal /proc/meminfo | awk '{print int($2/1024)}')
    
    #try to keep free_ram_goal MB free RAM on Linux at all times by setting the balloon size of the VM
    #Windows will eat as much RAM as possible for caches, so it can be reallocated as needed.
    #This "balloon_popper" process is what's needed to make the virtio-balloon driver actually do something.
    while true;do
      sleep 1
      qemu_pid="$(cat "$vmdir/qemu.pid" 2>/dev/null)"
      [ -z "$qemu_pid" ] && continue
      
      free_ram=$(grep MemAvailable /proc/meminfo | awk '{print int($2/1024)}')
      qemu_used_ram=$(grep VmRSS /proc/$qemu_pid/status | awk '{print $2/1024}' | sed 's/[.,].*//g')
      other_tasks_ram=$((total_ram - (qemu_used_ram + free_ram)))
      #echo "other taks use $other_tasks_ram"
      balloon_size=$((total_ram - other_tasks_ram - free_ram_goal))
      #echo "qemu using $qemu_used_ram, free $free_ram, balloon_size: $balloon_size"
      
      echo "balloon $balloon_size" | socat - UNIX-CONNECT:"$vmdir/qemu.sock" &>/dev/null
    done &
    balloon_popper=$!
    trap "kill $balloon_popper 2>/dev/null" EXIT SIGINT
    
    retrying=0
    time_before="$(sed 's/\..*//g' /proc/uptime)"
    while true;do #loop for re-running qemu after BSOD and removing UCPD.sys
      #run qemu with these flags
      if [ "$use_taskset" == false ];then
        qemu-system-aarch64 "${full_qemu_flags[@]}"
      else
        #For rockchip (untested but based on https://gist.github.com/Vogtinator/293c4f90c5e92838f7e72610725905fd?permalink_comment_id=5378278#gistcomment-5378278)
        taskset -c "$(echo "$use_cores" | tr '\n' ',' | sed 's/,$//g')" qemu-system-aarch64 "${full_qemu_flags[@]}"
      fi
      qemu_exit_code=$?
      
      if [ $qemu_exit_code == 0 ];then
        status "QEMU closed."
        
        time_after="$(sed 's/\..*//g' /proc/uptime)"
        if [ $((time_before+240)) -ge $time_after ];then
          if [ $retrying == 0 ];then
            #if qemu ran for less than 240 seconds, the VM likely had a BSOD. Try to fix it and run qemu one more time
            retrying=1
            
            warning "QEMU ran for less than 240 seconds. Windows likely experienced an error during boot. Trying to fix it..."
            
            mountpoint="/media/$USER/bvm-mount$rdp_port"
            if ! (mount_qcow2 "$vmdir/disk.qcow2") ;then
              (unmount_qcow2)
              (error "Failed to mount disk.qcow2 to complete repairs")
              break
            fi
            
            remove_UCPD_from_mountpoint "$mountpoint"
            unmount_qcow2
            #continue in loop to restart qemu
          else
            #qemu still exited with code 0 in less than 240 seconds
            warning "Even after attempted repairs, QEMU ran for less than 240 seconds. Windows likely experienced another BSOD during boot. Giving up."
            break
          fi
        else
          echo -e '\e[103m\e[30mConsider supporting the developer Botspot.\e[96m\e[40m  \e[4mhttps://github.com/sponsors/Botspot\e[0m'
          break
        fi
      else
        (exit $qemu_exit_code) ; qemu_exitcode_analyzer
        break
      fi
    done
    
    kill $balloon_popper
    sudo rm -f "$udev_file"
    ;;
  connect*)
    #make sure the qemu process is running
    if ! process_exists "$(cat "$vmdir/qemu.pid" 2>/dev/null)" ;then
      error "QEMU does not appear to be running. You need to run the VM first before you can view its screen."
    elif [ -z "$DISPLAY" ] && [ -z "$WAYLAND_DISPLAY" ];then
      error "BVM needs a desktop environment to run $mode"
    fi
    
    if [ "$XDG_SESSION_TYPE" == wayland ];then
      freerdp_command="wlfreerdp"
    else
      freerdp_command="xfreerdp"
    fi
    
    #wait for network port to open, indicating the machine is ready for connection
    status -n "Waiting for RDP service on VM to start listening on port $rdp_port... "
    while true;do
      #Once the RDP port is open, it means the VM is ready for connections
      if nmap -p "$rdp_port" --script="${DIRECTORY}/resources/rdp-detector.nse" --system-dns localhost | grep -qF 'RDP service detected';then
        break
      elif ! process_exists "$(cat "$vmdir/qemu.pid" 2>/dev/null)" ;then
        error "\nQEMU process is no longer running. Maybe the OS failed to boot."
      fi
      sleep 3
    done
    status_green Done
    
    while true;do #Relaunch the viewer between VM reboots
      case "$mode" in
        connect-freerdp)
          
          if ! command -v $freerdp_command ;then
            error "FreeRDP 2 cannot be installed on your OS, so it cannot be used. Please use Remmina to connect."
          fi
          
          freerdp_flags=(/v:127.0.0.1:$rdp_port /u:$vm_username /p:$vm_password /relax-order-checks /cert:ignore +auto-reconnect \
            /dynamic-resolution /sound +window-drag -sec-rdp -sec-tls +offscreen-cache +home-drive +menu-anims +multitouch \
            -compression -encryption +drives /auto-reconnect-max-retries:10 +async-input +async-channels +clipboard +gfx-progressive \
            /gfx +aero +bitmap-cache /t:"BVM connect")
          #support a reduced graphics mode that can be enabled in the config file - for x11 mainly
          if [ "$reduce_graphics" == true ];then
            freerdp_flags+=(-window-drag -aero -menu-anims)
          fi
          
          #fullscreen mode: add flag to enable it
          if [ "$fullscreen" == true ];then
            freerdp_flags+=(/f)
          fi
          
          $freerdp_command "${freerdp_flags[@]}" "${add_freerdp_flags[@]}"
          ;;
        connect-remmina|connect)
          
          #change remmina's graphical settings based on reduce_graphics setting
          if [ "$reduce_graphics" == true ];then
            quality=0
          else
            quality=9
          fi
          
          #Copy new-and-improved remmina config
          grep -qF 'to get microphone input working' "$vmdir/connect.remmina" 2>/dev/null || cp -f "${DIRECTORY}/resources/connect.remmina" "$vmdir/connect.remmina"
          #Use Remmina to set parameters in profile
          echo -e "$vm_username\n$vm_password\n127.0.0.1:$rdp_port\n$quality\n$HOME\n$(echo "$fullscreen" | sed 's/true/3/g ; s/false/1/g')" | remmina --update-profile "$vmdir/connect.remmina" --set-option username --set-option password --set-option server --set-option quality --set-option drive --set-option viewmode
          
          #fullscreen mode - enable toolbar, otherwise hide left-align toolbar which is mostly useless
          if [ "$fullscreen" == true ];then
            fullscreen_flag='--enable-fullscreen'
          else
            fullscreen_flag='--disable-toolbar'
          fi
          
          #now run remmina with its newly created/updated config file
          remmina -c "$vmdir/connect.remmina" --enable-extra-hardening --no-tray-icon $fullscreen_flag --class bvm --name bvm
          ;;
      esac
      status "RDP viewer exited. Analyzing..."
      sleep 6
      
      #wait for RDP service to come back, or exit loop if QEMU stopped
      messaged=0
      while true;do
        #Once the RDP port is open, it means the VM is ready for connections
        if ! process_exists "$(cat "$vmdir/qemu.pid" 2>/dev/null)" ;then
          status "VM is no longer running. Exiting $mode mode."
          exit 0 #end script, rdp exited because vm shutdown
        elif nmap -p "$rdp_port" --script="${DIRECTORY}/resources/rdp-detector.nse" localhost | grep -qF 'RDP service detected';then
          #if immediately back online, then no reboot took place. Wait for user input to reconnect
          if [ $messaged == 1 ];then
            status_green "VM is back online. Connecting..."
            sleep 5 #connecting too early sometimes had error about "another user is already connected"
            break #vm is still running and RDP is back, so reconnect to it
          else
            #immediately got to this state, so VM never went offline but RDP viewer closed.
            #ask for user input to prevent a forever failed connection loop
            status_green "VM never went offline."
            status -n "Assuming you disconnected. Press any key to reconnect, or Ctrl+C to unsafely force-kill the VM."
            read -N1 key
            break
          fi
        elif [ $messaged == 0 ];then
          status "VM appears to be rebooting. Waiting..."
          messaged=1
        fi
        sleep 3
      done
    done
    ;;
    
  mount) #browse and change files in disk.qcow2
    mount_qcow2 "$vmdir/disk.qcow2" #will exit right here on error
    trap "unmount_qcow2 &>/dev/null" EXIT SIGINT
    status "$vmdir/disk.qcow2 is now mounted to /media/$USER/bvm-mount$rdp_port"
    read -p "Press enter to unmount"
    unmount_qcow2
    ;;
    
  expand) #increase the size of disk.qcow2
    
    read -e -p "$(echo -ne '\e[96m')Enter number of gigabytes to ADD to the disk.qcow2 file: $(echo -ne '\e[0m')" -i 10 addsize
    if [ -z "$addsize" ];then
      echo "Canceling without making changes."
      exit 0
    fi
    addsize="$(echo "$addsize" | tr -cd '0123456789\n')" #sanitize input
    
    #expand disk
    status -n "Adding $addsize GB to file... "
    qemu-img resize "$vmdir/disk.qcow2" +"${addsize}"G | grep -vFx 'Image resized.'
    if [ ${PIPESTATUS[0]} != 0 ];then
      error "\nFailed to resize disk.qcow2 with qemu-img"
    fi
    status_green Done
    
    status -n "Getting ready to work on partitions... "
    #now device-ify qcow2 and expand filesystem on partition 4
    nbd_device="$(connect_qcow2_to_nbd "$vmdir/disk.qcow2")" || exit 1
    trap "sudo qemu-nbd --disconnect $nbd_device &>/dev/null" EXIT SIGINT
    status_green Done
    
    status -n "Expanding NTFS partition to take up new space... "
    #expand partition table and remove partition 5 if found
    if [ -b ${nbd_device}p5 ];then
      #updates GPT, removes partition 5
      sudo parted -s -f ${nbd_device} rm 5 2>&1 | grep -v '^Warning: Not all of the space available\|Fixing, due to --fix\|^$\|^[[:space:]]*$'
      #that can fail, though if it does the next parted command probably will too
    fi
    
    #resize partition 4 to expand to all new space
    sudo parted -s -f ${nbd_device} resizepart 4 100% 2>&1 | grep -v '^Warning: Not all of the space available\|Fixing, due to --fix\|Information: You may need to update /etc/fstab.\|^$\|^[[:space:]]*$'
    if [ ${PIPESTATUS[0]} != 0 ];then
      sudo qemu-nbd --disconnect ${nbd_device}
      error "\nFailed to expand 4th partition to fill the new space on disk"
    fi
    status_green Done
    
    #resize filesystem
    status "Expanding filesystem..."
    if ! sudo ntfsresize -f ${nbd_device}p4 ;then
      sudo qemu-nbd --disconnect ${nbd_device}
      error "\nFailed to expand filesystem to fill new space on 4th partition"
    fi
    status_green Done
    
    status -n "Cleaning up... "
    sudo qemu-nbd --disconnect ${nbd_device} 2>&1 | grep -vFx "$nbd_device disconnected"
    status_green Done
    ;;
  *)
    error "unknown mode '$mode'. Run $0 help to see available options."
    ;;
esac

exit 0

#Below is botspot's scratchpad of notes for getting this running. It is included here for future reference.
#No commands below will be run by this script. so they can be uncommented.

#Primary information sources that I used for reference:
#https://youtu.be/HOwslWR8LyY
#https://github.com/quickemu-project/quickemu

#if the install fails, use the mount mode and check for these files:
#/media/pi/bvm-mount/$Windows.~BT/Sources/Panther/setuperr.log
#/media/pi/bvm-mount/Windows/Panther/setuperr.log
#/media/pi/bvm-mount/Windows/Panther/UnattendGC/setupact.log

#get w11 lite - https://www.youtube.com/watch?v=HrM3xzzgawQ
#download from https://www.microsoft.com/en-us/evalcenter/download-windows-11-iot-enterprise-ltsc-eval
#direct download link: https://software-static.download.prss.microsoft.com/dbazure/998969d5-f34g-4e03-ac9d-1f9786c66749/26100.1742.240906-0331.ge_release_svc_refresh_CLIENT_IOT_LTSC_EVAL_A64FRE_en-us.iso
#disable hourly auto-shutdown after 90 days: https://digitalitskills.com/how-to-stop-windows-server-auto-shutdown-every-hour-after-license-expire/

#activate (run in windows) This is from some youtube video I found years back. Supposedly this is not illegal.
slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX
slmgr /skms kms.digiboy.ir
slmgr /ato
#https://github.com/Whitecat18/Windows-Activator/blob/main/Windows-Activator.bat
#https://github.com/CaptainChicky/Activate-Microsoft-products-for-testing-in-virtual-machines

#debloat and unattend:
#some unattend debloat stuff pulled from https://schneegans.de/windows/unattend-generator/
#https://github.com/Raphire/Win11Debloat
#https://github.com/agadiffe/WindowsMize/blob/main/WindowsMize.ps1
#https://github.com/memstechtips/UnattendedWinstall

#vm disk settings benchmarks to speed up firstboot (falloc, cache, cluster_size)
#https://events19.lfasiallc.com/wp-content/uploads/2017/11/Storage-Performance-Tuning-for-FAST-Virtual-Machines_Fam-Zheng.pdf

#solve weird usb passthrough issue - bad socket format
sudo journalctl -u systemd-udevd #many lines like this: event9: Process '/usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev' failed with exit code 1.
#see the issue, run it with strace
sudo strace /usr/sbin/th-cmd --socket /var/run/thd.socket --passfd --udev
#said something about bad socket format for /var/run/thd.socket 
sudo rm /var/run/thd.socket 
reboot

#display build information on desktop (run in windows)
reg add "HKCU\Control Panel\Desktop" /v PaintDesktopVersion /t REG_DWORD /d 0x00000001 /f

#logout on RDP disconnect (reduces idle CPU)
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services" /v MaxDisconnectionTime /t REG_DWORD /d 60000 /f

#reset hard drive
rm -f windows-11arm64/win11.qcow2
qemu-img create -f qcow2 windows-11arm64/win11.qcow2 40G

#upgrade qemu to 9.2
sudo apt install -t bookworm-backports --only-upgrade qemu-system-aarch64

#improves sound slightly
sudo renice -n -20 -p $(pgrep -f /usr/bin/pipewire)
sudo ionice -c 1 -n 0 -p $(pgrep -f /usr/bin/pipewire)

#botspot's findings:
-bios #is necessary for some reason
#specifying installation drives as usb is somehow necessary
# this breaks boot: -global driver=cfi.pflash01,property=secure,value=on
-vga none #seems to break the installer - cannot get drivers
#these fail to load unattended:
-drive media=cdrom,index=2,file=windows-11arm64/unattended.iso \
-drive media=cdrom,index=0,file=windows-11arm64/Win11_24H2_EnglishInternational_Arm64.iso \
-drive media=cdrom,index=1,file=windows-11arm64/virtio-win.iso \
-display sdl,gl=on #seems to break it. Needs to have no gl=on or sdl only
-device virtio-gpu-pci,xres=1280,yres=800 #with resolution parameters seems to break boot
-display spice-app,gl=on #works but display is completely garbled
-display #option omitted works great, dynamic resizing does work
-display spice-app #works great, dynamic resizing does not work
-display gtk (no gl=on) works
-display sdl #does not work (stuck on boot)
-vga none -device virtio-gpu-pci -display gtk works
-vga none -device virtio-gpu-pci -display sdl,gl=es
#list all display options: qemu-system-aarch64 -help | grep display
#get working audio: -device usb-audio,audiodev=my_audiodev -audiodev pipewire,id=my_audiodev

#usb device forwarding: https://gist.github.com/ichisadashioko/cfc6446764516bf7eccaffdb3799f041
 -usb -device usb-host,vendorid=0x'1a40',productid=0x'0101',driver=usb-host

#usb hub forwarding: not sure how to do it

#might help: https://github.com/darkguy2008/hotplugger and https://www.reddit.com/r/VFIO/comments/lbvgpr/hotplugger_real_usb_port_passthrough_for_vfioqemu/
#might help: https://serverfault.com/questions/667426/pass-an-usb-hub-from-a-kvm-host-to-a-guest-with-libvirt

#shared filesystem
#https://github.com/virtio-win/kvm-guest-drivers-windows/wiki/Virtiofs:-Shared-file-system

#list all devices: qemu-system-aarch64 -device help

#qemu-img create -f qcow2 windows-11arm64/usb-drive.qcow2 2G

#make ethernet bridge to share IP
#https://ahelpme.com/linux/howto-do-qemu-full-virtualization-with-macvtap-networking/
sudo ip link add link eth0 name macvtap0 type macvtap mode bridge
sudo ip link set macvtap0 up
sudo chown $USER:$USER /dev/tap$(cat /sys/class/net/macvtap0/ifindex)

#remmina is faster than all other viewing methods that work, has perfect audio too
#remmina config doc: https://remmina.gitlab.io/remminadoc.gitlab.io/md__builds__remmina_remmina_ci__remmina_wiki__remmina__config__file__options.html
#remmina colordepth options: https://github.com/FreeRDP/Remmina/blob/7bc15420b6e6a2a4540f20aeccfabe9cff4b7fd3/plugins/rdp/rdp_plugin.c#L1686
#cannot run program on startup because exec= uses FreeRDP_AlternateShell which is ignored by Windows 10/11
#See https://superuser.com/questions/1202758/how-to-use-rdp-alternative-shell-inital-program-in-windows-10education
#RemoteApp not supported by Remmina
#https://stackoverflow.com/questions/1226772/can-rdp-clients-launch-remote-applications-and-not-desktops
remmina -c /home/pi/windows-11arm64/group_rdp_quick-connect_127-0-0-1.remmina --enable-extra-hardening --no-tray-icon

#running apps individually outside a windows display environment using RemoteApp:
#https://github.com/xiagw/winapps
xfreerdp3 /v:127.0.0.1 /u:Quickemu /p:quickemu /relax-order-checks /cert:ignore +auto-reconnect /app:program:'%windir%\system32\cmd.exe'
#It keeps getting X11 errors on window resize events, sadly
#freerdp needs a fix, see my issue: https://github.com/FreeRDP/FreeRDP/issues/11218

#good command for high speed RDP
wlfreerdp /v:127.0.0.1 /u:Quickemu /p:quickemu /relax-order-checks /cert:ignore +auto-reconnect /dynamic-resolution /sound /workarea +window-drag -sec-rdp -sec-tls +offscreen-cache +home-drive +menu-anims +multitouch -compression -encryption +drives /auto-reconnect-max-retries:0 +async-input +async-channels +clipboard +gfx-progressive /gfx +aero  /t:"BVM Project - RDP Viewer"
#best wlfreerdp3 command I could get
wlfreerdp3 /v:127.0.0.1 /u:Quickemu /p:quickemu /relax-order-checks /cert:ignore +auto-reconnect /dynamic-resolution /sound  -async-update +async-channels /gfx:progressive/clearcodec
#wlfreerdp3 seems to not copy text from host to guest, so wlfreerdp it is I guess.

#pad firmware files to solve error "qemu-system-aarch64: device requires 67108864 bytes, block backend provides 1966080 bytes"
#solution found on https://www.kraxel.org/blog/2022/05/edk2-virt-quickstart/
if false;then
dd of="windows-11arm64/OVMF_VARS.fd" if="/dev/zero" bs=1M count=64
dd of="windows-11arm64/OVMF_VARS.fd" if="/usr/share/OVMF/OVMF_VARS.fd" conv=notrunc
dd of="windows-11arm64/OVMF_CODE.fd" if="/dev/zero" bs=1M count=64
dd of="windows-11arm64/OVMF_CODE.fd" if="/usr/share/OVMF/OVMF_CODE.fd" conv=notrunc
#OVMF_CODE does not work, but QEMU_EFI does
dd of="windows-11arm64/QEMU_EFI.fd" if="/dev/zero" bs=1M count=64
dd of="windows-11arm64/QEMU_EFI.fd" if="/usr/share/qemu-efi-aarch64/QEMU_EFI.fd" conv=notrunc
fi

#working command from https://youtu.be/HOwslWR8LyY:
qemu-system-aarch64 -M virt -cpu host -accel kvm -m 4G -smp 4 \
-device ramfb -device virtio-gpu-pci -bios /usr/share/qemu-efi-aarch64/QEMU_EFI.fd \
-device qemu-xhci -device usb-kbd -device usb-tablet \
-drive file=Win11_24H2_English_Arm64.iso,media=cdrom,if=none,id=inst -device usb-storage,drive=inst \
-drive file=virtio-win.iso,media=cdrom,if=none,id=iso -device usb-storage,drive=iso \
-drive file=win11.qcow2,if=virtio \
-nic user,model=virtio-net-pci,mac=00:11:22:33:44:55

#shortened version from quickemu (does not work)
/usr/bin/qemu-system-aarch64 -name windows-11arm64,process=windows-11arm64 -machine virt,highmem=on,accel=kvm \
-global kvm-pit.lost_tick_policy=discard -global ICH9-LPC.disable_s3=1 \
-cpu host -smp cores=4,threads=1,sockets=1 -m 4G \
-device virtio-balloon -pidfile windows-11arm64/windows-11arm64.pid \
-rtc base=localtime,clock=host,driftfix=slew \
-vga none -device virtio-gpu-pci,xres=1280,yres=800 -display sdl,gl=on \
-device virtio-rng-pci,rng=rng0 -object rng-random,id=rng0,filename=/dev/urandom \
-device usb-ehci,id=input \
-device usb-kbd,bus=input.0 -k en-us \
-device usb-tablet,bus=input.0 -audiodev pa,id=audio0 \
-device intel-hda \
-device virtio-net,netdev=nic -netdev user,hostname=windows-11arm64,hostfwd=tcp::22220-:22,id=nic -global driver=cfi.pflash01,property=secure,value=on \
-drive if=pflash,format=raw,unit=0,file=windows-11arm64/OVMF_CODE.fd,readonly=on \
-drive if=pflash,format=raw,unit=1,file=windows-11arm64/OVMF_VARS.fd \
-drive media=cdrom,index=2,file=windows-11arm64/unattended.iso \
-drive media=cdrom,index=0,file=windows-11arm64/Win11_24H2_EnglishInternational_Arm64.iso \
-drive media=cdrom,index=1,file=windows-11arm64/virtio-win.iso \
-device virtio-blk-pci,drive=SystemDisk -drive id=SystemDisk,if=none,format=qcow2,file=windows-11arm64/disk.qcow2

#quickemu
/usr/bin/qemu-system-aarch64 -name windows-11arm64,process=windows-11arm64 -machine virt,highmem=on,accel=kvm \
-global kvm-pit.lost_tick_policy=discard -global ICH9-LPC.disable_s3=1 \
-cpu host -smp cores=4,threads=1,sockets=1 -m 4G \
-device virtio-balloon -pidfile windows-11arm64/windows-11arm64.pid \
-rtc base=localtime,clock=host,driftfix=slew \
-vga none -device virtio-gpu-pci,xres=1280,yres=800 -display sdl,gl=on \
-device virtio-rng-pci,rng=rng0 -object rng-random,id=rng0,filename=/dev/urandom \
-device qemu-xhci,id=spicepass -chardev spicevmc,id=usbredirchardev1,name=usbredir \
-device usb-redir,chardev=usbredirchardev1,id=usbredirdev1 -chardev spicevmc,id=usbredirchardev2,name=usbredir \
-device usb-redir,chardev=usbredirchardev2,id=usbredirdev2 -chardev spicevmc,id=usbredirchardev3,name=usbredir \
-device usb-redir,chardev=usbredirchardev3,id=usbredirdev3 \
-device pci-ohci,id=smartpass \
-device usb-ccid -chardev spicevmc,id=ccid,name=smartcard \
-device ccid-card-passthru,chardev=ccid \
-device usb-ehci,id=input \
-device usb-kbd,bus=input.0 -k en-us \
-device usb-tablet,bus=input.0 \
-audiodev pa,id=audio0 -device intel-hda -device hda-micro,audiodev=audio0 \
-device virtio-net,netdev=nic -netdev user,hostname=windows-11arm64,hostfwd=tcp::22220-:22,id=nic -global driver=cfi.pflash01,property=secure,value=on \
-drive if=pflash,format=raw,unit=0,file=windows-11arm64/OVMF_CODE.fd,readonly=on \
-drive if=pflash,format=raw,unit=1,file=windows-11arm64/OVMF_VARS.fd \
-drive media=cdrom,index=2,file=windows-11arm64/unattended.iso \
-drive media=cdrom,index=0,file=windows-11arm64/Win11_24H2_EnglishInternational_Arm64.iso \
-drive media=cdrom,index=1,file=windows-11arm64/virtio-win.iso \
-device virtio-blk-pci,drive=SystemDisk \
-drive id=SystemDisk,if=none,format=qcow2,file=windows-11arm64/disk.qcow2 \
-monitor unix:windows-11arm64/windows-11arm64-monitor.socket,server,nowait \
-serial unix:windows-11arm64/windows-11arm64-serial.socket,server,nowait

#working command:
qemu-system-aarch64 -M virt -cpu host -accel kvm -m 4G -smp 4 -device virtio-gpu-pci -bios \
/usr/share/qemu-efi-aarch64/QEMU_EFI.fd -device qemu-xhci -device usb-kbd -device usb-tablet -drive file=win11.qcow2,if=virtio \
-nic user,model=virtio-net-pci,mac=00:11:22:33:44:55
